启动流程
==============

为什么要关注启动
----------------

虽然从本质上看，启动是一个简单而纯粹的过程。核心就是硬件初始化，从存储介质上加
载操作系统到内存，然后执行之。实际上，有一些开源项目，比如linuxboot，也确实就是
这样做的。

但在像鲲鹏这样的服务器平台上，实际实现方式要复杂的多。除了所有器件的自检和初始
化之外，一个典型的鲲鹏服务器运行需要的来自不同团队的软件组件，需要有序的启动。这
些软件组件包括：

* 运行在EL3的runtime service，一般会以ARM Trust Firmware修改而来，提供PSCI，SDEI，
  SPCI，SCMI等服务。
* 运行在SEL1的安全操作系统，在鲲鹏服务器上是开源的OP-TEE或者基于鸿蒙内核的方案。
* 运行在EL2的UEFI runtime service，TODO：具体提供什么服务
* 运行在EL2的虚拟化软件，在鲲鹏服务器上一般是KVM
* 运行在EL1的操作系统内核，在鲲鹏服务器上一般是各个版本的Linux内核

为了能够简化操作系统在不同芯片平台之间的迁移，ARM发布了SBBR（Server Base Boot
Requirements），对UEFI及相关服务做出了具体的要求，鲲鹏服务器遵循这一规范。

另外，所有提供安全服务的平台，为了保证自身的可信，关键的一步是实现可信的启动流
程。可信的启动流程在CPU执行的第一条指令开始，到完整的操作系统加载过程中，只加载和
执行预期的组件。为了实现这一点，ARM发布了TBBR(Trusted Board Boot Requirements)规
范，鲲鹏服务器也遵循了这一规范。

在进入UEFI之前
----------------

并不是在所有平台上都能方便的通过代码来理解系统启动到UEFI之前的过程。但是对于基
于ARM架构的鲲鹏来说，ARM开源的ARM Trusted Firmware（简称ATF），是最好的学习材料。
下文以TF-A（Trusted Firmware for ARM A-Profile architectures）实现为索引，简单描
述启动过程在鲲鹏上的实现方式。

下文提及源代码文件，都以TF-A代码根目录为起点。

**架构(architecture)与平台(platform)**

::

  在TF-A的代码中频繁出现architecture（经常以arch简写出现）和platform（经常以plat
  简写出现）。对于ARM来说architecture关注的是指令集架构，也就是在ISA手册中定义的
  内容。而platform，是系统运行所需，但超出ISA手册的范围。ARM将指令集架构授权给不
  同的厂商后，architectures依然是各家厂商共享共通的，但platform则各家有各家的实
  现方式。在整个TF-A代码中，architecture涵盖了aarch32和aarch64两种；而platform则
  包含了全胜、树莓派等多家产品的多款产品。

  所有名称中含有plat字样的接口，在TF-A代码中，都可以认为是由各个平台自行实现的。

  因为鲲鹏是兼容aarch64的，所以以下默认只关注aarch64这个architecture的实现。

作为整个启动的第一步，所有处理器都开始在EL3执行reset vector。这个地址一般位于
Trusted ROM中。在TF-A代码中，对应的实现位于bl1/aarch64/bl1_entrypoint.S。其中的
关键动作有

::

  el3_entrypoint_common

  bl1_setup
  bl1_main

在系统上电开始执行第一条指令的时候，所有状态易失的器件都处于不确定的状态，而处理
器自身可能还没有使能cache，也没有加入一致性域。启动过程的最前期，就是要把系统从
这样混沌的状态带到一个确定的状态。el3_entrypoint_common做的就是这样的一些工作

::


  _init_sctlr   // 配置关键系统寄存器状态
  if (plat_get_my_entrypoint())
    do_cold_boot  // 区分冷启动还是温重启，做一些初始化操作
  adr x0, \_exception_vectors         // load exception vector
  msr vbar_el3, x0              // load exception vector
  isb                     // load exception vector
  el3_arch_init_common // 架构初始化
  if (plat_is_my_cpu_primary())
    do_primary_cold_boot  // 区分是否是主CPU，执行不同的启动初始化工作。
  else
    plat_secondary_cold_boot_setup 

el3_entrypoint_common调用plat_get_my_entrypoint，对cold boot还是warm reset做了
区分。并不是所有的平台实现都包含在TF-A的开源代码中，也不是所有的ARM平台都对
cold boot和warm reset做了区分。详细的实现可以看plat/arm/board中的各个平台汇编文
件。

之后初始化的异常向量，定义在bl1/aarch64/bl1_exceptions.S中。因为这是非常早期的
运行环境，这个阶段的异常向量handler实现也异常简单。

再之后，el3_entrypoint_common还通过调用plat_is_my_cpu_primary，对CPU是否是主
CPU做了区分，主CPU则执行do_primary_cold_boot，而其他CPU则执行
plat_secondary_cold_boot_setup。其中do_primary_cold_boot中做了内存初始化，为后
续运行准备了C语言执行环境，包括栈的初始化。而如果是
plat_secondary_cold_boot_setup，则一般实现为在特定地址上循环等待主CPU的命令。
需要注意，这表示ARM从设计上把多处理器的启动方式交由各个平台自行决定，我们在启动
流程的后期还会看到这个设计决策的影响。

bl1_setup是个非常简单的调用，他完成平台特定的初始化动作 ::

  bl1_early_platform_setup();
  bl1_plat_arch_setup();

以hikey960为例，前者做了timer的初始化，检测board id并根据board id初始化了串口，
使能BL1阶段能够访问所有Trusted RAM；而后者做了MMU初始化。

bl1_main包含的关键动作 ::

  print_errata_status(); //打印当前固件中已经集成的针对当前CPU的ERRATA状态
  bl1_arch_setup();    // 将下个EL中的执行模式设置为aarch64
  auth_mod_init();    // 为TBBR做初始化
  bl1_platform_setup();

  image_Id = bl1_plat_get_next_image_id();
  if (image_id == BL2_IMAGE_ID)
    bl1_load_bl2();
  else 
    NOTICE("BL1-FWU: **** FWU Process Started ****\n");
  bl1_prepare_next_image(image_id)

CPU和软件一样，设计和实现过程中会因为各种原因导致问题，这些问题的修正在ARM架构
中被称为ERRATAS。在lib/cpus/aarch64中，我们可以看到针对各类已经发布ARM CPU的汇
编文件，其中包含了各自的ERRATAS。以lib/cpus/aarch64/cortax_a75.S为例，当前版本
中能看到errata_a75_764081_wa, errata_a75_790748_wa等等。其中的数字编号，可以在
ARM官方网站上检索到详细的说明。

我们把目光拉回到bl1_main中，bl1_platform_setup则也是由各个platform自行定义的行
为，比如plat/rpi/rpi3/rpi3_bl1_setup.c中，就只是对单板的版本做了检测，并初始化
IO。

bl1_plat_get_next_image_id()获取了下一个启动阶段BL2所使用的镜像的ID。如果这个
ID不是BL2_IMAGE_ID，ATF默认下一步会启动FWU的过程。虽然从TF-A的代码上看不到对
firmware update过程的调用，但是伏笔已经埋在更早的阶段中了。bl1_exception定义的
异常向量表中，bl1_smc_handler会判断类型并且相应调用bl1_fwu_smc_handler。相应的
实现在bl1/bl1_fwu.c中，这里不再展开。

传统的观念中，硬件的缺陷修复，需要召回并且返厂修理才能解决。这是非常不方便而且
昂贵的。通过固件的方式修正CPU的实现缺陷，给服务器平台的管理带来了极大的灵活性；
同时结合在启动过程中升级firmware的流程，使得数据中心管理人员对芯片安全漏洞不再
缩手无策。在2018年初发生的那次著名的CPU安全漏洞风波（Spectre/Meltdown 详情可见
https://meltdownattack.com/ ）中，ARM架构同样存在推测运行机制的硬件设计缺陷，
正是因为有ERRATA和FWU的存在，鲲鹏服务器可以被有效管理并规避安全风险。

BL1的实现到这里就告一段落，我们转向BL2。
