.. Copyright by Kenneth Lee. All Right Reserved.

地址翻译和保护
==============

介绍
----
现代服务器几乎都提供虚拟地址服务。这出于如下考虑：

* 安全的需要。现代服务器需要给不同的角色赋予不同的权限，就需要给不同的软件实体
  赋予不同的权限，那么控制不同的地址空间对不同的角色不同的访问权限，就成为基本
  的要求了。

* 虚拟分层的需要。在例如虚拟机这样的层次，系统软件需要为被虚拟的软件模拟一个“看
  似”真实的地址空间，这也需要对目标地址进行转换。

* 地址空间扩展的需要。部分低端的设备，地址总线的长度不如系统总线，无法访问系统
  总线上的部分设备，地址翻译服务器可以扩展这个地址，让这些设备的地址范围可以提
  升。

鲲鹏通过MMU和IOMMU单元提供地址翻译服务。其结构示意如下：

.. figure:: kunpeng_mmu_smmu.svg
        :alt: Kungpeng MMU & SMMU

        鲲鹏MMU和IOMMU服务

鲲鹏的主CPU由于使用ARM标准，所以完全遵循ARMv8构架标准，而IOMMU遵循ARM SMMU标准。
但无论使用的是哪个标准，其原理基本上是不变的。两者都采用（相同格式）的页表格式
描述虚拟地址到物理地址的转换关系，以及对应地址段的关系。

地址空间和页式地址翻译
-----------------------
todo: 页式管理的本质介绍：本质是一个地址翻译算法，而用页进行管理页表本身占用的空间太大

        | 虚拟地址、物理地址、中间地址
        | todo

todo：两级页表的概念, 说明现在两级页表的弊病：虚拟机和Hypervisor是两个软件，这个
设置不应该是两者一同修改的。

todo：TLB的考量，介绍TLB软件填充模式和自动填充模式，介绍最坏情况下两次填充的效率问题

todo：ASID概念的介绍

IOMMU和MMU的基本原理本质没有什么不同，但两者在页表的使用上有明显的差别。CPU通过
MMU管理多套页表，通常可以封装为进程。当CPU决定把一个进程调度到本CPU上运行的时候，
CPU把这个进程可以访问的所有虚拟地址和物理地址对应关系设置在这个页表上，这样就控
制了当前进程可以访问的实际地址的范围。

todo: 地址空间示意图

Linux使用共享内核空间的结构，所有进程共享同一个内核空间，所以所有进程的内核空间
都是重叠的，这样，无论CPU当前在哪个进程，只要提升它的CPU权限，就都可以访问内核的
服务。这里的细节我们在讨论计算子系统的时候再详细讨论。

todo：Linux地址空间示意图

IOMMU
------
IOMMU页表描述结构
`````````````````
和MMU这种每个CPU用一个唯一的页表的策略不同，IOMMU每个设备支持多个页表。这首先是
为了解决虚拟机的问题，如果一个设备被虚拟化成了多个虚拟设备。每个虚拟机需要对设
备施加多个独立的请求，这些请求的地址可能是重合的，这客观上要求多个独立的页表才能
实现。

鲲鹏在设计上对于IOMMU给予了更多的期望，鲲鹏设想IOMMU机制可以让设备和进程拥有相同
的地址空间，从而把让设备的功能可以按进程进行管理。这个设计原理，我们也在介绍计算
子系统的时候一起讨论。

为了支持多页表，鲲鹏的IOMMU采用了SMMU标准的两层的页表描述机制。这种机制下，每个
IOMMU首先包含一张页表描述表，每个表表项称为Descriptor，可以再描述一张单独的页表
。并且和内核或者一个ASID对应。当设备发出地址请求的时候，它同时给出它的ASID（或者
说明它是内核请求），

todo：IOMMU页表空间示意图

IOMMU的No-Strict模式问题
`````````````````````````
todo：解释IOMMU map/unmap的成本和No-Strict模式问题
