

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>启动流程 &mdash; 从鲲鹏920了解现代服务器实现和应用 0.1a1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 从鲲鹏920了解现代服务器实现和应用
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../序.html">序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../感谢.html">感谢</a></li>
<li class="toctree-l1"><a class="reference internal" href="../认识服务器/index.html">认识服务器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../认识鲲鹏920：一个服务器SoC/index.html">认识鲲鹏920：一个服务器SoC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../计算子系统/index.html">计算子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../网络子系统/index.html">网络子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../存储子系统/index.html">存储子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RAS设计/index.html">RAS设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../未来展望.html">未来展望</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">从鲲鹏920了解现代服务器实现和应用</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>启动流程</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/启动和运行管理/启动流程.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>启动流程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>为什么要关注启动<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>虽然从本质上看，启动是一个简单而纯粹的过程。核心就是硬件初始化，从存储介质上加
载操作系统到内存，然后执行之。实际上，有一些开源项目，比如linuxboot，也确实就是
这样做的。</p>
<p>但在像鲲鹏这样的服务器平台上，实际实现方式要复杂的多。除了所有器件的自检和初始
化之外，一个典型的鲲鹏服务器运行需要的来自不同团队的软件组件，需要有序的启动。这
些软件组件包括：</p>
<ul class="simple">
<li>运行在EL3的runtime service，一般会以ARM Trust Firmware修改而来，提供PSCI，SDEI，
SPCI，SCMI等服务。</li>
<li>运行在SEL1的安全操作系统，在鲲鹏服务器上是开源的OP-TEE或者基于鸿蒙内核的方案。</li>
<li>运行在EL2的UEFI runtime service，TODO：具体提供什么服务</li>
<li>运行在EL2的虚拟化软件，在鲲鹏服务器上一般是KVM</li>
<li>运行在EL1的操作系统内核，在鲲鹏服务器上一般是各个版本的Linux内核</li>
</ul>
<p>为了能够简化操作系统在不同芯片平台之间的迁移，ARM发布了SBBR（Server Base Boot
Requirements），对UEFI及相关服务做出了具体的要求，鲲鹏服务器遵循这一规范。</p>
<p>另外，所有提供安全服务的平台，为了保证自身的可信，关键的一步是实现可信的启动流
程。可信的启动流程在CPU执行的第一条指令开始，到完整的操作系统加载过程中，只加载和
执行预期的组件。为了实现这一点，ARM发布了TBBR(Trusted Board Boot Requirements)规
范，鲲鹏服务器也遵循了这一规范。</p>
</div>
<div class="section" id="uefi">
<h2>在进入UEFI之前<a class="headerlink" href="#uefi" title="永久链接至标题">¶</a></h2>
<p>并不是在所有平台上都能方便的通过代码来理解系统启动到UEFI之前的过程。但是对于基
于ARM架构的鲲鹏来说，ARM开源的ARM Trusted Firmware（简称ATF），是最好的学习材料。
下文以TF-A（Trusted Firmware for ARM A-Profile architectures）实现为索引，简单描
述启动过程在鲲鹏上的实现方式。</p>
<p>下文提及源代码文件，都以TF-A代码根目录为起点。</p>
<p><strong>架构(architecture)与平台(platform)</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>在TF-A的代码中频繁出现architecture（经常以arch简写出现）和platform（经常以plat
简写出现）。对于ARM来说architecture关注的是指令集架构，也就是在ISA手册中定义的
内容。而platform，是系统运行所需，但超出ISA手册的范围。ARM将指令集架构授权给不
同的厂商后，architectures依然是各家厂商共享共通的，但platform则各家有各家的实
现方式。在整个TF-A代码中，architecture涵盖了aarch32和aarch64两种；而platform则
包含了全胜、树莓派等多家产品的多款产品。

所有名称中含有plat字样的接口，在TF-A代码中，都可以认为是由各个平台自行实现的。

因为鲲鹏是兼容aarch64的，所以以下默认只关注aarch64这个architecture的实现。
</pre></div>
</div>
<p>作为整个启动的第一步，所有处理器都开始在EL3执行reset vector。这个地址一般位于
Trusted ROM中。在TF-A代码中，对应的实现位于bl1/aarch64/bl1_entrypoint.S。其中的
关键动作有</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">el3_entrypoint_common</span>

<span class="n">bl1_setup</span>
<span class="n">bl1_main</span>
</pre></div>
</div>
<p>在系统上电开始执行第一条指令的时候，所有状态易失的器件都处于不确定的状态，而处理
器自身可能还没有使能cache，也没有加入一致性域。启动过程的最前期，就是要把系统从
这样混沌的状态带到一个确定的状态。el3_entrypoint_common做的就是这样的一些工作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>_init_sctlr   // 配置关键系统寄存器状态
if (plat_get_my_entrypoint())
  do_cold_boot  // 区分冷启动还是温重启，做一些初始化操作
adr x0, \_exception_vectors         // load exception vector
msr vbar_el3, x0              // load exception vector
isb                     // load exception vector
el3_arch_init_common // 架构初始化
if (plat_is_my_cpu_primary())
  do_primary_cold_boot  // 区分是否是主CPU，执行不同的启动初始化工作。
else
  plat_secondary_cold_boot_setup
</pre></div>
</div>
<p>el3_entrypoint_common调用plat_get_my_entrypoint，对cold boot还是warm reset做了
区分。并不是所有的平台实现都包含在TF-A的开源代码中，也不是所有的ARM平台都对
cold boot和warm reset做了区分。详细的实现可以看plat/arm/board中的各个平台汇编文
件。</p>
<p>之后初始化的异常向量，定义在bl1/aarch64/bl1_exceptions.S中。因为这是非常早期的
运行环境，这个阶段的异常向量handler实现也异常简单。</p>
<p>再之后，el3_entrypoint_common还通过调用plat_is_my_cpu_primary，对CPU是否是主
CPU做了区分，主CPU则执行do_primary_cold_boot，而其他CPU则执行
plat_secondary_cold_boot_setup。其中do_primary_cold_boot中做了内存初始化，为后
续运行准备了C语言执行环境，包括栈的初始化。而如果是
plat_secondary_cold_boot_setup，则一般实现为在特定地址上循环等待主CPU的命令。
需要注意，这表示ARM从设计上把多处理器的启动方式交由各个平台自行决定，我们在启动
流程的后期还会看到这个设计决策的影响。</p>
<p>bl1_setup是个非常简单的调用，他完成平台特定的初始化动作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bl1_early_platform_setup</span><span class="p">();</span>
<span class="n">bl1_plat_arch_setup</span><span class="p">();</span>
</pre></div>
</div>
<p>以hikey960为例，前者做了timer的初始化，检测board id并根据board id初始化了串口，
使能BL1阶段能够访问所有Trusted RAM；而后者做了MMU初始化。</p>
<p>bl1_main包含的关键动作</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">print_errata_status</span><span class="p">();</span> <span class="o">//</span><span class="n">打印当前固件中已经集成的针对当前CPU的ERRATA状态</span>
<span class="n">bl1_arch_setup</span><span class="p">();</span>    <span class="o">//</span> <span class="n">将下个EL中的执行模式设置为aarch64</span>
<span class="n">auth_mod_init</span><span class="p">();</span>    <span class="o">//</span> <span class="n">为TBBR做初始化</span>
<span class="n">bl1_platform_setup</span><span class="p">();</span>

<span class="n">image_Id</span> <span class="o">=</span> <span class="n">bl1_plat_get_next_image_id</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">image_id</span> <span class="o">==</span> <span class="n">BL2_IMAGE_ID</span><span class="p">)</span>
  <span class="n">bl1_load_bl2</span><span class="p">();</span>
<span class="k">else</span>
  <span class="n">NOTICE</span><span class="p">(</span><span class="s2">&quot;BL1-FWU: **** FWU Process Started ****</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
<span class="n">bl1_prepare_next_image</span><span class="p">(</span><span class="n">image_id</span><span class="p">)</span>
</pre></div>
</div>
<p>CPU和软件一样，设计和实现过程中会因为各种原因导致问题，这些问题的修正在ARM架构
中被称为ERRATAS。在lib/cpus/aarch64中，我们可以看到针对各类已经发布ARM CPU的汇
编文件，其中包含了各自的ERRATAS。以lib/cpus/aarch64/cortax_a75.S为例，当前版本
中能看到errata_a75_764081_wa, errata_a75_790748_wa等等。其中的数字编号，可以在
ARM官方网站上检索到详细的说明。</p>
<p>我们把目光拉回到bl1_main中，bl1_platform_setup则也是由各个platform自行定义的行
为，比如plat/rpi/rpi3/rpi3_bl1_setup.c中，就只是对单板的版本做了检测，并初始化
IO。</p>
<p>bl1_plat_get_next_image_id()获取了下一个启动阶段BL2所使用的镜像的ID。如果这个
ID不是BL2_IMAGE_ID，ATF默认下一步会启动FWU的过程。虽然从TF-A的代码上看不到对
firmware update过程的调用，但是伏笔已经埋在更早的阶段中了。bl1_exception定义的
异常向量表中，bl1_smc_handler会判断类型并且相应调用bl1_fwu_smc_handler。相应的
实现在bl1/bl1_fwu.c中，这里不再展开。</p>
<p>传统的观念中，硬件的缺陷修复，需要召回并且返厂修理才能解决。这是非常不方便而且
昂贵的。通过固件的方式修正CPU的实现缺陷，给服务器平台的管理带来了极大的灵活性；
同时结合在启动过程中升级firmware的流程，使得数据中心管理人员对芯片安全漏洞不再
缩手无策。在2018年初发生的那次著名的CPU安全漏洞风波（Spectre/Meltdown 详情可见
<a class="reference external" href="https://meltdownattack.com/">https://meltdownattack.com/</a> ）中，ARM架构同样存在推测运行机制的硬件设计缺陷，
正是因为有ERRATA和FWU的存在，鲲鹏服务器可以被有效管理并规避安全风险。</p>
<p>BL1的实现到这里就告一段落，我们转向BL2。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>