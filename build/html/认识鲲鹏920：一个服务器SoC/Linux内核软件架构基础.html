

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Linux内核软件架构基础 &mdash; 从鲲鹏920了解现代服务器实现和应用 0.1a1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="地址空间" href="地址空间.html" />
    <link rel="prev" title="软件架构" href="软件构架.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 从鲲鹏920了解现代服务器实现和应用
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../序.html">序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../感谢.html">感谢</a></li>
<li class="toctree-l1"><a class="reference internal" href="../认识服务器/index.html">认识服务器</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">认识鲲鹏920：一个服务器SoC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="综述.html">综述</a></li>
<li class="toctree-l2"><a class="reference internal" href="总线.html">总线</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件构架.html">软件架构</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Linux内核软件架构基础</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">汇编初始化过程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">运行参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">多核支持逻辑</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">动态模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">驱动框架</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="地址空间.html">地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="Cache.html">Cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="Cache.html#cache-coherency">Cache Coherency</a></li>
<li class="toctree-l2"><a class="reference internal" href="中断.html">中断</a></li>
<li class="toctree-l2"><a class="reference internal" href="设备和设备总线.html">设备和设备总线</a></li>
<li class="toctree-l2"><a class="reference internal" href="管理系统.html">管理系统</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../计算子系统/index.html">计算子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../网络子系统/index.html">网络子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../存储子系统/index.html">存储子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RAS设计/index.html">RAS设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../未来展望.html">未来展望</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">从鲲鹏920了解现代服务器实现和应用</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">认识鲲鹏920：一个服务器SoC</a> &raquo;</li>
        
      <li>Linux内核软件架构基础</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/认识鲲鹏920：一个服务器SoC/Linux内核软件架构基础.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="linux">
<h1>Linux内核软件架构基础<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>介绍<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>本书介绍软件实例的时候，主要使用Linux作为例子，所以很多地方都会涉及Linux内核的
实现。我们这里不是写一本关于Linux内核的书，但我们需要和读者建立一个共识，让读者
在一定程度上和我们有对于Linux代码有接近的看法，所以我们在本章介绍一些基本Linux
架构逻辑。</p>
<p>本章的介绍主要以5.5的内核为代码基线，我们尽量聚焦到核心逻辑上，所以相关的逻辑也
可以推广到其他的版本。但如果涉及细节，那就只能针对每个具体的细节版本来说了。这
一点请读者注意。</p>
<p>我们假定读者对一个用户态的普通C程序的代码的工作原理是熟悉的。Linux内核其实和一
个普通的C进程很接近，对大部分程序员来说，他们只关心main函数，不关心main函数的前
面的汇编准备过程，如果读者不关心更多的细节，其实也不需要关心汇编的初始化过程，
Linux内核的代码从init/main.c:start_kernel()开始执行，然后一个模块一个模块调用它
们的初始化函数，完成所有的初始化以后，最后调用do_idle()进入等待状态，这之后就是
等着各种外部刺激激发内核响应不同的操作了。这种刺激可以是：</p>
<ul class="simple">
<li>中断</li>
<li>系统调用</li>
</ul>
<p>这和我们创建写一个网络服务程序，创建很多线程等待客户端请求，然后主程序进入Idle
等待的运行模型是一样的。</p>
</div>
<div class="section" id="id2">
<h2>汇编初始化过程<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>但我们仍说明一下汇编的初始化过程。和普通程序一样，大部分时候Linux内核也是一个
ELF程序。这个ELF的代码的布局在它的ld script中定义，鲲鹏920作为通用的ARM服务器，
它的ld script就在这里：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">vmlinux</span><span class="o">.</span><span class="n">lds</span><span class="o">.</span><span class="n">S</span>
</pre></div>
</div>
<p>从这里我们可以找到它的程序入口：</p>
<div class="highlight-as notranslate"><div class="highlight"><pre><span></span> <span class="nx">ENTRY</span><span class="p">(</span><span class="nx">_text</span><span class="p">)</span>
 <span class="p">...</span>
 <span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">text</span> <span class="o">:</span> <span class="p">{</span>
         <span class="nx">_text</span> <span class="o">=</span> <span class="p">.;</span>
         <span class="nx">HEAD_TEXT</span>
 <span class="p">}</span>
 <span class="p">...</span>
 <span class="p">.</span><span class="nx">text</span> <span class="o">:</span> <span class="p">{</span>
         <span class="nx">_stext</span> <span class="o">=</span> <span class="p">.;</span>
                 <span class="nx">IRQENTRY_TEXT</span>
                 <span class="nx">SOFTIRQENTRY_TEXT</span>
                 <span class="nx">ENTRY_TEXT</span>
                 <span class="nx">TEXT_TEXT</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>这段定义表明，这个ELF文件的入口地址在_text上，而_text定义为.text段的首地址，而
.text段包含多个子段（部分不存在），……我们忽略这些细节，最后可以找到这个入口：</p>
<blockquote>
<div>arch/arm64/kernel/head.S:_head</div></blockquote>
<p>顺着这个入口走下去，完成最基本的内存准备，最后就会走到这里：</p>
<div class="highlight-as notranslate"><div class="highlight"><pre><span></span>__primary_switched:
        ...
        add     sp, sp, #16
        mov     x29, #0
        mov     x30, #0
        b       start_kernel
ENDPROC(__primary_switched)
</pre></div>
</div>
<p>后面的行为，就是基本的C语言的范畴了。</p>
</div>
<div class="section" id="id3">
<h2>运行参数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>C的main函数有argc和argc，Linux Kernel使用cmdline作为输入参数，这些参数由
Bootloader负责加载到内存中，通过特定的寄存器告知内核。</p>
<p>在服务器解决方案中，常见的方法是BIOS把Grub作为二级Bootloader进行加载，然后用
Grub加载内核，Grub中就可以给内核指定启动参数：</p>
<p>todo: grub.cfg的示例。</p>
<p>这些参数在内核中有一个详细的说明文档，在
Documentation/admin-guide/kernel-parameters.txt文件中。内核代码中有专门的代码
框架处理这些参数，读者可以全局搜索__setup()和__setup_param()宏的使用，这个宏的
定义如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __setup_param(str, unique_id, fn, early)                        \</span>
<span class="cp">        static const char __setup_str_##unique_id[] __initconst         \</span>
<span class="cp">                __aligned(1) = str;                                     \</span>
<span class="cp">        static struct obs_kernel_param __setup_##unique_id              \</span>
<span class="cp">                __used __section(.init.setup)                           \</span>
<span class="cp">                __attribute__((aligned((sizeof(long)))))                \</span>
<span class="cp">                = { __setup_str_##unique_id, fn, early }</span>

<span class="cp">#define __setup(str, fn)                                                \</span>
<span class="cp">        __setup_param(str, fn, fn, 0)</span>
</pre></div>
</div>
<p>其中str是参数的名称，fn是对应的初始化函数。内核初始化流程中有一个比较早期的步骤，
会找到所有的这些定义，回调相应的fn，以完成一些基本的参数设置。</p>
<p>Linux启动以后，可以从/proc/cmdline获得当前使用的命令行参数。</p>
<p>Cmdline提供用户修改Linux内核运行行为的机会，但内核正常运行还需要Bootloader提供
的硬件参数。部分硬件参数可以从硬件寄存器上获得，比如PCI设备就可以通过总线枚举流
程自动发现，但部分硬件才是硬连线决定的，并没有什么太好的方法自动发现出来。这只
能通过Bootloader直接传递。</p>
<p>比较常用的传递参数的方法有Device Tree和ACPI接口。Device Tree是一种NoSQL数据库的
形态，通过一张树状的描述表描述系统中的所有设备和参数，Linux初始化的时候从这个描
述表中读到对应的参数，为部分核心模块提供参数，或者创建设备对象，匹配对应的驱动
从而提供支持。ARM平台支持Device Tree方式访问，并且很多硬件平台把自己的Device
Tree表放在Linux内核中，读者可以从如下目录看到这些定义：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">boot</span><span class="o">/</span><span class="n">dts</span><span class="o">/</span>
</pre></div>
</div>
<p>Device Tree比较简单直接，但它描述的是一个相对静态的数据结构，比较适合嵌入式系统
，现在Device Tree也能支持Boot Loader动态修改表格结构，但仍不是特别灵活。</p>
<p>作为服务器，鲲鹏920主要使用的是ACPI的接口。ACPI本来是一个用于电源管理的接口标准，
但要做电源管理，就需要描述系统的结构，所以慢慢它就变成了一个描述系统结构的标准
接口了。</p>
<blockquote>
<div><div class="line-block">
<div class="line">ACPI</div>
<div class="line">todo</div>
</div>
</div></blockquote>
<p>ACPI一大特点是支持AML语言，AML可以编译成本本地代码，ACPI的用户可以直接调这些代
码来获得参数。这让它支持更为动态的行为。比如你得到一个设备，你可以直接调用AML函
数执行Reset，这不需要描述接口说明Reset寄存器是什么，写多少是Reset，之类的，只要
提供这个函数，就可以实现设备复位，这样比Devtree灵活得多。</p>
<p>Linux内核对这些接口都支持，BIOS传递过来的参数中使能了什么，就用什么。驱动可以同
时支持用两种方式获得参数，也可以支持其中一种。从架构上来说，这总能做到，如果读
者关心细节，可以直接看相关的代码。hns_enet.c是一个典型的例子，它的probe函数
同时判断device tree和acpi的配置，根据相应的配置进行类似的初始化过程。</p>
<p>hns_enet是鲲鹏之前的服务器CPU的内置网卡驱动，在鲲鹏920中，网卡设备都虚拟化为
PCIe设备，在它的驱动hns3_enet中，设备参数通过硬件自动枚举发现，就不需要这些配置
了。</p>
</div>
<div class="section" id="id4">
<h2>多核支持逻辑<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>CPU核是互相独立的实体，每个CPU核按指定的指令序列执行代码，它们之间要互相影响，
只能通过通过核间发中断，或者在内存中通过共享的变量互相传递信息。当系统包含多个
核的时候，它们每个也只能从各自的复位初始地址上开始进入执行。但这样一来，内核的
初始化就很难同步了。</p>
<p>Linux内核对硬件做这样的假设：在Linux内核被投入执行的时候，只有一个CPU核（通常是
0核）被投入运行，也就是说，_stext函数是0核运行的，在系统初始化的前期，只有0核在
工作，等0核完成多核都需要的基本数据结构的初始化了，就通过硬件指定的方法启动其他
核，其他核再进入复位向量。这段代码在start_kernel的后期，创建内核线程kernel_init
后，在kernel_init()一开始调用kernel_init_freeable()-&gt;smp_init()完成。</p>
<p>之后0核之外的其他核也从_stext向量进入，根据自己的CPU ID（从系统寄存器中获得），
使用约定的自己的数据结构进行初始化，这可以通过定义CPU数量大小的数组实现。在ARMv8
兼容平台上，这会进入secondary_start_kernel()作为C语言的入口。这个地方不需要和
其他平台共享代码，因为只要调度器已经被初始化了，同时这个CPU的状态切换成在线，
CPU就可以响应线程创建和从其他核迁移进程过来的请求，这个CPU就可以负责调度系统中
分配的线程和进程了。</p>
<div class="figure">
<img alt="../_images/multi-core-os-enable.svg" src="../_images/multi-core-os-enable.svg" /></div>
</div>
<div class="section" id="id5">
<h2>动态模块<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>Linux是个很大的程序，下面这个是鲲鹏上一个bash进程的大小（来自这个pid的
/proc/&lt;pid&gt;/smaps文件）：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aaaaca312000</span><span class="o">-</span><span class="n">aaaaca405000</span> <span class="n">r</span><span class="o">-</span><span class="n">xp</span> <span class="mi">00000000</span> <span class="mi">08</span><span class="p">:</span><span class="mi">02</span> <span class="mi">23592962</span>                   <span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">bash</span>
<span class="n">aaaaca414000</span><span class="o">-</span><span class="n">aaaaca419000</span> <span class="n">r</span><span class="o">--</span><span class="n">p</span> <span class="mi">000</span><span class="n">f2000</span> <span class="mi">08</span><span class="p">:</span><span class="mi">02</span> <span class="mi">23592962</span>                   <span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">bash</span>
<span class="n">aaaaca419000</span><span class="o">-</span><span class="n">aaaaca422000</span> <span class="n">rw</span><span class="o">-</span><span class="n">p</span> <span class="mi">000</span><span class="n">f7000</span> <span class="mi">08</span><span class="p">:</span><span class="mi">02</span> <span class="mi">23592962</span>                   <span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">bash</span>
<span class="o">...</span>
</pre></div>
</div>
<p>忽略其他动态库，这里的r-xp是它的代码段，大小不到1MB。而相同平台上的Linux Kernel
的大小如下（来自内核打印Buffer dmesg）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Memory</span><span class="p">:</span> <span class="mi">526958844</span><span class="n">K</span><span class="o">/</span><span class="mi">536866688</span><span class="n">K</span> <span class="n">available</span> <span class="p">(</span><span class="mi">12092</span><span class="n">K</span> <span class="n">kernel</span> <span class="n">code</span><span class="p">,</span> <span class="mi">1694</span><span class="n">K</span> <span class="n">rwdata</span><span class="p">,</span> <span class="mi">5112</span><span class="n">K</span> <span class="n">rodata</span><span class="p">,</span> <span class="mi">5504</span><span class="n">K</span> <span class="n">init</span><span class="p">,</span> <span class="mi">1161</span><span class="n">K</span> <span class="n">bss</span><span class="p">,</span> <span class="mi">9875076</span><span class="n">K</span> <span class="n">reserved</span><span class="p">,</span> <span class="mi">32768</span><span class="n">K</span> <span class="n">cma</span><span class="o">-</span><span class="n">reserved</span><span class="p">)</span>
</pre></div>
</div>
<p>代码段的大小是12M。这么大的程序，很多功能其实用不到。Linux就把部分功能做成独立
的模块，动态加载。这种动态加载的模块称为LKM，Linux Kernel Module。在Linux运行
的时候可以通过lsmod命令看到它有那些模块是动态加载的。</p>
<p>LKM的源代码形态中有自己的初始化和反初始化函数，如果在内核编译配置的时候把一个模
块编译为LKM，它就会变独立链接为.ko文件，这个文件被加载到内核中的时候，这个初始化
函数就会被调用，一边这个动态模块可以被注册到内核的其他子系统中，而这个模块被卸载
的时候，它的反初始化函数会被调用，从而脱离那些子系统的注册。</p>
<p>编译者也可以考虑把这些模块编译为内核的一部分，这些模块就不需要动态加载，而是在内
核完成核心系统的初始化后，统一调用他们的初始化函数。这就和一个普通的C程序的模块
没有什么区别了。</p>
<p>Linux内核中包含很多硬件的驱动，这些驱动大部分都会被实现为动态模块。因为不是每个
硬件平台都有这些硬件，包含这些驱动并没有意义。但LKM并不一定是硬件驱动，硬件驱动
也不需要一定是LKM。</p>
</div>
<div class="section" id="id6">
<h2>驱动框架<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>驱动操作系统中对硬件进行封装的代码。在一些操作系统中，操作系统只包含很少的一部
分驱动代码，其他代码通过类似LKM那样的技术动态加载（但这不是必须的，部分操作系统
也可以用进程作为驱动），而且这些动态加载的程序和OS没有密切关系，可以一定程度上
有不同的版本偏离。比如1.0的驱动，可以用于1.0, 2.0, 2.1的操作系统中。</p>
<p>所以很多用户对驱动的理解类似一个类似进程一样的独立实体。但Linux不是这样的，
Linux的驱动是内核的一部分，它们没有互相分离的版本，默认两者是一同编译的。（但正
如我们一直说的，每种架构判断都有可能有人做变种，我们这里只讨论设计意图）</p>
<p>抛开部署的逻辑，Linux内核在数据结构上用三个结构去管理驱动：</p>
<ul class="simple">
<li>struct driver，表示一段可以支持某种硬件的代码。</li>
<li>struct bus_type，表示一种总线类型，这是一个逻辑概念，不需要表示一条真实存在的
总线，在本小结中，我们把它简称为bus。</li>
<li>struct device，表示一个设备，这是标识这个设备的数据结构，物理的总线也可以是一
个device。</li>
</ul>
<p>bus_type通常是一个静态的结构，表示某种类型的总线，driver和device都可以注册到
bus_type中，bus_type有机制保证任意一方注册到总线中，它就可以通过一个bus专属的
match函数，判断两者是否匹配（比如PCI总线可以匹配driver支持什么vendor和device id
，然后匹配加进来的device的vendor和device id是否一致，如果一致，就说明两者匹配成
功了），就调用driver提供的probe函数，用struct device作为输入，驱动就可以用
device的数据初始化硬件，并且把这个硬件注册到特定的子系统中了。</p>
<p>整个逻辑组织起来就是这样的：</p>
<ol class="arabic simple">
<li>内核启动或者LKM插入的时候，驱动程序负责向自己支持的总线注册自己的驱动接口。</li>
<li>硬件平台初始化代码根据硬件平台的特点创建device，注册给不同的总线。这个可以硬
编码，也可以是对device tree或者ACPI配置的解释。也注册到对应的总线上</li>
<li>1, 2两步不分先后，如果匹配上，就会产生probe，probe负责初始化硬件，并注册子
系统</li>
<li>注册的设备中如果包含总线控制器，它可以创建更多的bus，然后扫描自己的总线，把
设备加入这个新的总线中。它也可以直接把新的设备加入已经存在的bus中。</li>
</ol>
<p>所以，最终如果有driver没有device，driver就只是闲着，有device没有driver，device
也只是闲着。Linux还有其他机制在device加入bus的时候通知用户态的helper，尝试找一
个匹配的LKM插入内核以驱动这个device。这是另一套逻辑，而且不是主要的逻辑，我们这
里忽略。</p>
<p>driver, bus, device都是“对象”，Linux使用kobject来管理它们，在Linux启动后，我们
可以从sysfs上查看这些对象。sysfs通常被大部分发行版mount在/sys目录中，下面是一个
/sys/bus的内容：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac97</span>         <span class="n">container</span>  <span class="n">event_source</span>  <span class="n">isa</span>           <span class="n">memory</span>    <span class="n">nvmem</span>        <span class="n">platform</span>  <span class="n">serial</span>       <span class="n">typec</span>   <span class="n">workqueue</span>
<span class="n">acpi</span>         <span class="n">cpu</span>        <span class="n">gpio</span>          <span class="n">machinecheck</span>  <span class="n">mipi</span><span class="o">-</span><span class="n">dsi</span>  <span class="n">parport</span>      <span class="n">pnp</span>       <span class="n">serio</span>        <span class="n">usb</span>     <span class="n">xen</span>
<span class="n">cec</span>          <span class="n">dax</span>        <span class="n">hdaudio</span>       <span class="n">mdio_bus</span>      <span class="n">mmc</span>       <span class="n">pci</span>          <span class="n">rapidio</span>   <span class="n">snd_seq</span>      <span class="n">virtio</span>  <span class="n">xen</span><span class="o">-</span><span class="n">backend</span>
<span class="n">clockevents</span>  <span class="n">edac</span>       <span class="n">hid</span>           <span class="n">media</span>         <span class="n">nd</span>        <span class="n">pci</span><span class="o">-</span><span class="n">epf</span>      <span class="n">scsi</span>      <span class="n">spi</span>          <span class="n">vme</span>
<span class="n">clocksource</span>  <span class="n">eisa</span>       <span class="n">i2c</span>           <span class="n">mei</span>           <span class="n">node</span>      <span class="n">pci_express</span>  <span class="n">sdio</span>      <span class="n">thunderbolt</span>  <span class="n">wmi</span>
</pre></div>
</div>
<p>我们看pci_express的内容：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span> <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span>    <span class="mi">0</span> <span class="mi">3</span><span class="n">月</span>   <span class="mi">5</span> <span class="mi">15</span><span class="p">:</span><span class="mi">17</span> <span class="n">devices</span>
<span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span> <span class="mi">6</span> <span class="n">root</span> <span class="n">root</span>    <span class="mi">0</span> <span class="mi">3</span><span class="n">月</span>   <span class="mi">5</span> <span class="mi">15</span><span class="p">:</span><span class="mi">17</span> <span class="n">drivers</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">4096</span> <span class="mi">3</span><span class="n">月</span>   <span class="mi">5</span> <span class="mi">15</span><span class="p">:</span><span class="mi">17</span> <span class="n">drivers_autoprobe</span>
<span class="o">--</span><span class="n">w</span><span class="o">-------</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">4096</span> <span class="mi">3</span><span class="n">月</span>   <span class="mi">5</span> <span class="mi">15</span><span class="p">:</span><span class="mi">17</span> <span class="n">drivers_probe</span>
<span class="o">--</span><span class="n">w</span><span class="o">-------</span> <span class="mi">1</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">4096</span> <span class="mi">3</span><span class="n">月</span>   <span class="mi">5</span> <span class="mi">15</span><span class="p">:</span><span class="mi">17</span> <span class="n">uevent</span>
</pre></div>
</div>
<p>devices和drivers目录指向对应的devices和drivers的kobject所在的目录。
drivers_autoprobe等文件称为这个kobject的“属性”，可以通过读写这些属性改变这个
kobject的行为。比如，我们可以通过driver的unbind属性强行解绑定一个device等等。</p>
<p>对于服务器，最重要的两个bus_type是platform和pci。前者用于没有总线控制，无条件连
接的设备，这种总线的匹配通常就只能是字符串匹配。后者用于PCI和PCIe等设备的匹配，
配备方法就是PCI协议规定的Vendor和Device ID匹配了。</p>
<p>在驱动写作的时候，hns_enet用的就是platform设备，它的driver定义是这样的：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">hns_enet_of_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;hisilicon,hns-nic-v1&quot;</span><span class="p">,},</span>
        <span class="p">{.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;hisilicon,hns-nic-v2&quot;</span><span class="p">,},</span>
        <span class="p">{},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">acpi_device_id</span> <span class="n">hns_enet_acpi_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span> <span class="s">&quot;HISI00C1&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s">&quot;HISI00C2&quot;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
        <span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">hns_nic_dev_driver</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
                <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;hns-nic&quot;</span><span class="p">,</span>
                <span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">hns_enet_of_match</span><span class="p">,</span>
                <span class="p">.</span><span class="n">acpi_match_table</span> <span class="o">=</span> <span class="n">ACPI_PTR</span><span class="p">(</span><span class="n">hns_enet_acpi_match</span><span class="p">),</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">hns_nic_dev_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">hns_nic_dev_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>这里提供了对device tree（of_mastch_table）和ACPI两个匹配表，任何一个配置文件
中描述了这个设备，都可以匹配这个驱动。</p>
<p>而鲲鹏920使用PCIe设备，它的driver定义就是这样的：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">hns3_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_GE</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_25GE</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_25GE_RDMA</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_25GE_RDMA_MACSEC</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_50GE_RDMA</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_50GE_RDMA_MACSEC</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_100G_RDMA_MACSEC</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_100G_VF</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>
        <span class="p">{</span><span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">HUAWEI</span><span class="p">,</span> <span class="n">HNAE3_DEV_ID_100G_RDMA_DCB_PFC_VF</span><span class="p">),</span>
         <span class="n">HNAE3_DEV_SUPPORT_ROCE_DCB_BITS</span><span class="p">},</span>
        <span class="cm">/* required last entry */</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">hns3_driver</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="n">hns3_driver_name</span><span class="p">,</span>
        <span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">hns3_pci_tbl</span><span class="p">,</span>
        <span class="p">.</span><span class="n">probe</span>    <span class="o">=</span> <span class="n">hns3_probe</span><span class="p">,</span>
        <span class="p">.</span><span class="n">remove</span>   <span class="o">=</span> <span class="n">hns3_remove</span><span class="p">,</span>
        <span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">hns3_shutdown</span><span class="p">,</span>
        <span class="p">.</span><span class="n">sriov_configure</span> <span class="o">=</span> <span class="n">hns3_pci_sriov_configure</span><span class="p">,</span>
        <span class="p">.</span><span class="n">err_handler</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">hns3_err_handler</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="地址空间.html" class="btn btn-neutral float-right" title="地址空间" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="软件构架.html" class="btn btn-neutral float-left" title="软件架构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>