

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>总线系统 &mdash; 从鲲鹏920了解现代服务器实现和应用 0.1a1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="地址翻译和保护" href="地址翻译和保护.html" />
    <link rel="prev" title="综述" href="综述.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> 从鲲鹏920了解现代服务器实现和应用
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../序.html">序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../感谢.html">感谢</a></li>
<li class="toctree-l1"><a class="reference internal" href="../认识服务器/index.html">认识服务器</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">认识鲲鹏920：一个服务器SoC</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="综述.html">综述</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">总线系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mmio">MMIO和物理地址编址</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cache">Cache</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cacheline">Cacheline</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cache-prefetch">Cache Prefetch</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cache-coherency">Cache Coherency</a></li>
<li class="toctree-l2"><a class="reference internal" href="地址翻译和保护.html">地址翻译和保护</a></li>
<li class="toctree-l2"><a class="reference internal" href="NUMA和内存访问效率.html">NUMA和内存访问效率</a></li>
<li class="toctree-l2"><a class="reference internal" href="GIC和总线的关系.html">GIC和总线的关系</a></li>
<li class="toctree-l2"><a class="reference internal" href="虚拟PCIE总线.html">虚拟PCIE总线</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件构架设计.html">软件架构设计</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../计算子系统/index.html">计算子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../网络子系统/index.html">网络子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../存储子系统/index.html">存储子系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RAS设计/index.html">RAS设计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../未来展望.html">未来展望</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">从鲲鹏920了解现代服务器实现和应用</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">认识鲲鹏920：一个服务器SoC</a> &raquo;</li>
        
      <li>总线系统</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/认识鲲鹏920：一个服务器SoC/总线系统.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>总线系统<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>概述<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>鲲鹏使用一条全局的Cache Coherent的总线把所有的设备连在一起，使CPU和设备都可以访
问系统中的任何内存。</p>
<blockquote>
<div><div class="line-block">
<div class="line">Cache Coherent</div>
<div class="line">由于跨越总线访问其他数据需要时间，肯定不如直接在本子系统中直接访问的</div>
<div class="line">速度快，设计者会为本子系统设计本地的缓冲，这个缓冲称为Cache。Cache带</div>
<div class="line">来了性能的提升，但同时也带来对数据的多副本问题。部分总线的设计，需要</div>
<div class="line">每个子系统自己处理这种多副本问题。而Cache Coherent的总线本身带了协议</div>
<div class="line">解决这样的同步问题，可以保证如果一个副本给更新了，其他副本在被读取前</div>
<div class="line">总是被更新了的。</div>
</div>
</div></blockquote>
<p>计算机的总线互联技术称为NoC，Network on Chip。是一个独立的技术门类，其中包括介
质，拓扑，安全，算法等各方面专门的研究。每种计算会根据自己的需求特点，选择不同
的技术方案和参数。</p>
<p>鲲鹏920使用以环状总线为基础的总线技术，下面是一个示意图：</p>
<div class="figure" id="id3">
<img alt="Kungpeng Ring Bus" src="../_images/kunpeng_ring_bus.svg" /><p class="caption"><span class="caption-text">鲲鹏环状总线示意图</span></p>
</div>
<p>环状总线结构有点像城市里的环线地铁：列车在一个环线上一直循环，在每个车站停车上
下乘客，无限循环。环状总线在时钟的驱动下，每个时钟周期，电路逻辑把数据从一个
Station发送到下一个Station。这种每次发送的数据称为Flit，多个Flit组成一个Packet，
Station向Packet加入自己的Flit或者读走发给自己的Flit。有了这样一个基础，总线就可
以在时钟的驱动上，一直循环把数据发给每个Station。</p>
<p>不同的应用会选择不同的总线参数，比如鲲鹏920的Flit为了保证Latency，会选择70%的空
载率，而使用相同技术的Hi1980（市场上所知的达芬奇AI芯片），首先保证吞吐率，它的
Flit利用率就会高达90%。</p>
<p>环状总线是Super Cluster内部的机制，如果需要跨越Super Cluster，就需要在部分
Station上实现数据的“转乘”，从另一条线路出去。下面是一个鲲鹏920 4 SoC互联的示意
图：</p>
<p>todo：需要画一副4P的互联示意图，特别需要标识一下内存控制器的位置。</p>
<p>通过这样一个结构，无论是同一个芯片内部还是多个芯片互联，系统里的任意两个单元都
是可以互相访问的。</p>
<p>对于鲲鹏，由于同一个封装之内的线路是可控的，所以跨Super Cluster的总线是不经过
Serdes电路的，而跨封装的，就需要经过这样一个过程了。所以，从通讯效率上看，Super
Cluster内是最快的，跨封装相对来说是最慢的，但作为总线，它仍比读写内存本身快得多
。</p>
<p>下面是一个我们在鲲鹏920上访问不同区域内存的速度测试：</p>
<p>todo：需要一个内存测试数据。</p>
<blockquote>
<div><div class="line-block">
<div class="line">Serdes</div>
<div class="line">Serdes是Serializer/Deserializer的缩写。现代计算机互联技术向高速发展后</div>
<div class="line">并行总线由于信号干扰的问题，很难在芯片之外的布线中实现，所以，在实际</div>
<div class="line">在进行芯片之外的互联中，都会使用串行通讯电路，这样就需要专门的技术实现</div>
<div class="line">这种串行和反串行的过程，这种方法，实践和具体的技术，称为Serdes。</div>
</div>
</div></blockquote>
<p>但我们也看到了，其实数据转到系统不同位置上的时间是不同的。现代片上网络设计有很
多新的发展，比如通过3D的互联结构，提供更多样的路由优化，或者改变Flit的调度和流
控算法减少冲突等。但如果考虑到越来越多的节点和前面提到的引线的问题。我们几乎可
以预期未来更多核的系统，必然是NUMA系统。程序员是肯定需要关心到被访问的地址和本
设备的距离的。作为程序员的读者可能可以把这个作为未来开发的一个基本考虑。</p>
<blockquote>
<div><div class="line-block">
<div class="line">NUMA</div>
<div class="line">Non-uniform memory access. 这是一种计算机内存构架，不同位置的内存对</div>
<div class="line">不同的CPU的访问速度是不同的。感知NUMA的软件可以通过使用靠近本CPU的内</div>
<div class="line">存，从而让性能达到最优。</div>
</div>
</div></blockquote>
<p>总线系统是鲲鹏所有全局设计的中心，CPU和设备访问内存，CPU访问设备，设备之间互相
访问，乃至中断的分发，都基于这个总线系统。后面我们会看到更多和它相关的设计。</p>
</div>
<div class="section" id="mmio">
<h2>MMIO和物理地址编址<a class="headerlink" href="#mmio" title="永久链接至标题">¶</a></h2>
<p>早期的计算机都把和内存的通讯，以及和设备的通讯分开。由于访问效率和访问功能不同
访问内存和进行设备通讯用的总线也不同。但随着技术的发展，这种分离已经逐渐没有必
要了。</p>
<blockquote>
<div><div class="line-block">
<div class="line">MMIO</div>
<div class="line">Memory Mapped Input/Ouput。</div>
<div class="line">MMIO是为了区分把内存和IO访问分离的技术而建立的概念。</div>
<div class="line">它表示内存和IO是在一个地址空间中编址的一种总线地址应用方式。</div>
</div>
</div></blockquote>
<p>鲲鹏920就使用一条系统总线沟通所有的设备和内存控制器。所以它访问内存的某个位置和
访问某个设备的方法从指令上看起来都是一样的。无论设备还是CPU发出地址请求，经过
MMU或者SMMU翻译，最后都会成为Flit中的一个请求，这个请求中包含读写类型，访问字长
，安全标记，写入数据等等信息，从一个Station发出去，这个Station会根据目标地址得
到目标的Station ID，Flit到达目的地Station，就会从那里读走，然后控制目标一侧的设
备做出反应。无论是读写，也无论消息的目标是内存控制器还是设备，最后都是消息。</p>
<p>当然，在这个消息之上的协议行为可能是不同的，比如写操作可能就不需要等待目标设备
响应，读操作就需要等待。读写内存可以基于Cacheline一次读写整个Cacheline，读设备
这需要严格根据字长的要求进行控制。如果内存配置了交织访问，还需要对请求进行拆解
，变成多个针对不同目标的请求。鲲鹏通过一个实现在每个Station中的称为DAW（Danymic
Address Window）的设计对地址的范围进行判断，再根据这个判断决定最终的Flit的内容。
DAW在BIOS配置阶段由BIOS全局分配给每个Station，从而让每个Station的用户有全局唯一
的地址空间。</p>
<p>鲲鹏920使用48位物理地址，其中x位（todo：4位？要确认一下）用于DAW窗口，剩下的是
Station内部使用的偏移地址，这整个地址都在Flit内，收到的设备如何处理它，就是地址
读写协议的问题了。</p>
<p>从编程的角度，我们可以从两方面来控制CPU或者设备发出的地址请求。其一是发出的地址
的指令指定的字长。鲲鹏遵循ARMv8标准，ARMv8对不同的字长有不同的访问指令，比如：</p>
<ul class="simple">
<li>8位读写 strb, ldrb</li>
<li>16位读写 strh, ldrh</li>
<li>32/64位读写 str, ldr （取决于操作数的不同会生成不同的指令编码）</li>
<li>128位读写 stp, ldp</li>
</ul>
<p>这些指令只是CPU的期望，当这些请求发到MMU上，MMU要根据地址对其进行解释，再变成物
理地址。下面是一种ARMv8的页表的格式：</p>
<blockquote>
<div><div class="figure">
<img alt="认识鲲鹏920：一个服务器SoC/armv8_4k_pte_format.svg" src="认识鲲鹏920：一个服务器SoC/armv8_4k_pte_format.svg" /></div>
</div></blockquote>
<p>其中的MemAttr指明了这个目标地址是内存类型的还是设备类型的，内存类型分三种：</p>
<ul class="simple">
<li>MemAttr[3:2]=01 Inner或者Outer NonCacheable</li>
<li>MemAttr[3:2]=10 Outer Write-through Cacheable</li>
<li>MemAttr[3:2]=11 Outer Write-back Cacheable</li>
</ul>
<p>Inner和Outter基本上是两种Cache Coherency的界限，Inner之内内存是CC的，Outter则需
要任用进行Cache同步。鲲鹏920上，对所有计算子系统和内存，都是Inner域中的内存。</p>
<p>Write-through和Write-back，是两种常见的Cache写入算法，表示写入Cache的时候是否理
解更新内存。</p>
<p>Inner的内存又分三种：</p>
<ul class="simple">
<li>MemAttr[1:0]=01 NonCacheable</li>
<li>MemAttr[1:0]=10 Write-through Cacheable</li>
<li>MemAttr[1:0]=11 Write-back Cacheable</li>
</ul>
<p>设备（MemAttr[3:2]=00）分四种类型：</p>
<ul class="simple">
<li>MemAttr[1:0]=00 nGnRnE</li>
<li>MemAttr[1:0]=01 nGnRE</li>
<li>MemAttr[1:0]=10 nGRE</li>
<li>MemAttr[1:0]=11 GRE</li>
</ul>
<p>这里定义了三种访问行为定义：</p>
<ul class="simple">
<li>G，Gatthering，这表示是否允许MMU和总线收集多个请求以后一次发出去</li>
<li>R，Reordering，这个表示是否允许MMU和总线对同一个通讯目标重排请求的顺序</li>
<li>E，Write Acknowledgement，这个表示如何认可一个写操作成功了。E表示等写响应消息
回来才是写成功了，nE表示只要发出去就成功了。</li>
</ul>
<p>todo：鲲鹏在实现G、R、E的时候的特殊考虑。</p>
<p>在5.5主线的Linux Kernel的实现中，我们可以看到它默认选择的属性：</p>
<p>这是设备的映射：
.. code-block:: c</p>
<blockquote>
<div>//arch/arm64/include/asm/io.h
#define ioremap(addr, size)             __ioremap((addr), (size), __pgprot(PROT_DEVICE_nGnRE))
#define ioremap_wc(addr, size)          __ioremap((addr), (size), __pgprot(PROT_NORMAL_NC))</div></blockquote>
<p>这是内存的映射：
.. code-block:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">mm</span><span class="o">/</span><span class="n">proc</span><span class="o">.</span><span class="n">S</span>
<span class="n">ldr</span>     <span class="n">x5</span><span class="p">,</span> <span class="o">=</span><span class="n">MAIR</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">MT_DEVICE_nGnRnE</span><span class="p">)</span> <span class="o">|</span> \
             <span class="n">MAIR</span><span class="p">(</span><span class="mh">0x04</span><span class="p">,</span> <span class="n">MT_DEVICE_nGnRE</span><span class="p">)</span> <span class="o">|</span> \
             <span class="n">MAIR</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">,</span> <span class="n">MT_DEVICE_GRE</span><span class="p">)</span> <span class="o">|</span> \
             <span class="n">MAIR</span><span class="p">(</span><span class="mh">0x44</span><span class="p">,</span> <span class="n">MT_NORMAL_NC</span><span class="p">)</span> <span class="o">|</span> \
             <span class="n">MAIR</span><span class="p">(</span><span class="mh">0xff</span><span class="p">,</span> <span class="n">MT_NORMAL</span><span class="p">)</span> <span class="o">|</span> \
             <span class="n">MAIR</span><span class="p">(</span><span class="mh">0xbb</span><span class="p">,</span> <span class="n">MT_NORMAL_WT</span><span class="p">)</span>
<span class="n">msr</span>     <span class="n">mair_el1</span><span class="p">,</span> <span class="n">x5</span>
</pre></div>
</div>
<p>这个地方用的页表格式和我们前面举的例子用的那个不太一样，它的内存属性不是直接放
在页表项中的，而是页表项放一个索引，内容放在寄存器MAIR中，这里MT_NORMAL是5，所
以其实索引了NORMAL_WT的配置，但最终逻辑都是一样的。</p>
<p>ARMv8支持双Stage页表翻译，每个Stage支持多种页表格式，每种页表还支持多种页的大小
。所以这里其实有很多的变体，但其实我们不是那么关心这些实现细节，我们主要还是希
望通过这个实例，让读者对于访存的语义映射为一种硬件的行为的时候，大致会有哪些方
面的细节问题需要被考量有所了解。</p>
<p>综合起来，CPU发出一个总线地址请求，这个请求会有自己的要求，但MMU和DAW也会对这个
请求做出自己的理解，并按这个理解对这个请求进行二次解释，最终变成对设备（包括DDR
控制器）的请求。</p>
<p>这也说明了按抽象层次的语义编程的重要性。在这种合作和发展的过程中，每个抽象层次
只是维持自己保证的语义，在新的版本中可能会在没有承诺的部分做出改变，如果工程是
按“我试过了，这样可以”的心态来写程序，可能任何一个环节升级，这个程序就不能工作
了。</p>
<p>有些设备是对访问的长度和方法是有明确要求的，比如下面是鲲鹏920的加速器设备设置邮
箱命令的方法，它强行使用128位的访问，如果分开成两次64位访问，就会出错：</p>
</div>
<div class="section" id="cache">
<h2>Cache<a class="headerlink" href="#cache" title="永久链接至标题">¶</a></h2>
<p>Cache互联设计的典型优化手段。它基于两个简单的想法：</p>
<ol class="arabic simple">
<li>如果一个访问对象很远，而我又没有确定最终的结果，我可以先用更近的对象暂存数据
，等确切决定这个最终结果了，再一次更新到那个对象上。</li>
<li>如果一个访问对象很慢，而我又没有确定最终的结果，我可以先用更快的对象暂存数据
，等确切决定这个最终结果了，再一次更新到那个对象上。</li>
</ol>
<p>这个想法的前提是这个事实存在：“我还没有确定最终的结果”，这个事实不是总是存在的，
比如做IO的时候：我在内存中有一个数据包，我需要发到设备上，发完我就要发新的数据
了，这时做Cache就是多余的。但如果我要对这个数据包做计算，对每一段都做一个
Checksum，然后还要根据里面的域进行查表，然后更新他们的内容，这个结果没有完成之
前，这些数据除了本CPU任何其他总线上的设备都不关心，这时，使用Cache就有必要了。</p>
<p>下面是鲲鹏920的内存三级Cache设计示意图：</p>
<p>todo：晚点画这个图。</p>
<p>todo：介绍L3 tag和data分离的设计。</p>
<p>不同级别Cache的访问速度是差别是很大的，下面是鲲鹏920不同级别Cache访问速度的参考
数据：</p>
<p>todo：Cache访问数据参考数据。</p>
<p>Cache可以设计成对程序员透明，也可以设计成不透明。所谓透明，就是程序员可以不认为
存在Cache，认为自己访问的就是内存，所有因为Cache可能造成的误会，都由硬件想办法
弥补。而不透明就是程序员知道自己正在使用的是Cache还是实际的内存，主动维护两种内
存的关系。现代服务器基本都使用透明设计，但这些透明大部分时候只是对功能透明，对
性能并不透明，所以进行性能优化的时候，常常还是要考虑到Cache存在的影响。</p>
<div class="section" id="cacheline">
<h3>Cacheline<a class="headerlink" href="#cacheline" title="永久链接至标题">¶</a></h3>
<p>讨论Cache不能回避的一个问题是Cacheline，我们理解一下为什么会存在Cacheline。所有
的暂存表，都存在一个比原表小的问题，然后会会存在一个地址离散的问题。原表可以是
连续地址，每个地址都有内容。而暂存表不行，你的每个空间都会需要一个地址说明它是
原表的哪个位置。对于内存来说，这个成本尤其高，因为一个地址和地址的内容基本上信
息量是一样的。所以，从逻辑上说，无论我们用什么算法来解决这个问题，一个地址代表
一个足够长的内容是必然的。这个足够长的内容，就是一个Cacheline。</p>
<p>而为了效率，如果针对的是内存，大部分访问者，都会以Cacheline为单位来获取内存，即
使你访问的仅仅是Cachenline中的一个字节。这样，把数据结构按Cacheline的长度对齐，
就会有访问上的优势。</p>
<p>todo：多级Cache的Cacheline长度不一样的问题如何考量？</p>
<p>在编程上，我们知道实现是一回事，但程序员还是应该遵循语义来编程，一般程序最好不
要感知Cacheline的长度，只有在性能强相关的关键程序中，才适合去获取本平台的
Cacheline长度。对于Linux平台，大部分时候我们可以通过getconf命令或者sysconf系统
调用获得这些参数。</p>
<p>todo：鲲鹏920的平台上如何知道Cachenline的长度？</p>
</div>
<div class="section" id="cache-prefetch">
<h3>Cache Prefetch<a class="headerlink" href="#cache-prefetch" title="永久链接至标题">¶</a></h3>
<p>Cache Prefetch也是一个针对Cache的优化设计。Cache比实际的内存快很多，所以如果我
们可以提前加载部分内存到Cache中，就会在性能上有优势。</p>
<p>鲲鹏920支持ARMv8的prfm指令，这个指令……todo</p>
</div>
</div>
</div>
<div class="section" id="cache-coherency">
<h1>Cache Coherency<a class="headerlink" href="#cache-coherency" title="永久链接至标题">¶</a></h1>
<p>todo</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="地址翻译和保护.html" class="btn btn-neutral float-right" title="地址翻译和保护" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="综述.html" class="btn btn-neutral float-left" title="综述" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>