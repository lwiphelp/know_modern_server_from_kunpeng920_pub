.. Copyright by Kenneth Lee. 2020. All Right Reserved.

设备和设备总线
==============

前面介绍总线的时候我们介绍了鲲鹏的总线结构，本章我们看看设备是怎么连到总线上的。

忽略一些分关键功能的辅助设备，基于鲲鹏920构成的系统有两种类型的设备，一种内置在
SoC内，直接连接在NoC上。另一种是片外的，这些设备主要通过PCIe总线接入系统。还有
一些非高速设备使用其他一些特殊手段连接的，那些不是设计的重点，我们先忽略，等需
要介绍特定的设计的时候再讨论。

为了软件编程的方便，鲲鹏920的片内设备也提供PCIe一样的编程接口，所以，要理解这些
设备的设计，我们也需要先了解PCIe的工作原理。

PCIe
-----

PCIe从PCI接口发展而来，它向前兼容PCI的软硬件接口，旧的PCI接口卡可以插到PCIe的硬
件插槽中，旧的PCI驱动也可以直接驱动这些设备。这一方面带来了生态上的稳定，但另一
方面也带来很多不必要的负担。

正如我们前面提到的，PCIe对于PCI的一大升级是从并行总线换成了基于Serdes的多Lane
P2P串行总线。图示如下：

.. figure:: pci_vs_pcie.svg

所以PCIe总线和鲲鹏的系统总线不同，它是一个树状的分层架构：

.. figure:: pcie-arch.svg

其中的RC是一个虚拟的概念，相当于软件对于PCI设备访问的一个抽象，实现相关，之后是
链接出去的独立的终点（EP，End Point）或者网桥，网桥复制这个结构，就形成整个网络
了。

这样的网络结构在理解上反而相对简单，不会像PCI总线那样，每个高层语义都要转化为物
理信号。PCIe的高层语义直接可以建立在通讯语义的基础上。这个协议上分成三层：

* 会话层：定义总线不同业务，比如内存/IO访问，中断，低功耗处理等的通讯和消息协议

* 数据链路层：定义会话，链路，通道等协议

* 物理层：定义Serdes层的协议要求

用户能感知的是会话层，直接决定功能。数据链路层，对使用者的感知呈现为对设备QoS的
控制，通过配置总线属性来访问。而物理层，基本上对用户不可见。

正因为这样一个架构，鲲鹏920的片内设备很容易就封装为会话层接口，对软件提供PCIe的
设备语义。鲲鹏还支持CCIX协议，这个协议工作在PCIe的数据链路层上，替换了会话层，
只要修改一下PCIe控制器的工作模式，就可以让部分端口工作在CCIX模式上了。


地址空间
````````

前面说过，PCI/PCIe的最大特点是提供了系统总线一样的语义，可以直接通过地址访问直
接访问每个设备。

但对于PCIe总线，这个问题比一般的系统总线设备会复杂得多。系统总线是固定的，有多
少设备以开始就可以知道，配合DAW机制，我们可以给每个设备固定的地址空间。而对于
PCIe的网桥，我们可以给它一个地址空间，对于PCIe网桥，本身，怎么知道哪个地址是属
于哪个设备的呢？

这涉及PCIe总线控制器的枚举过程，BIOS或者OS在使用PCIE设备前，需要扫描整个总线结
构，找到每个通讯节点，给它指定地址，这样未来再发地址请求过来，PCIe的设备和网桥
就知道如何处理这个地址了。

PCIe控制器支持三种地址：

* 配置地址，这在PCI标准中称为配置空间，在PCIe中作了扩展，称为ECAM空间，Enhanced
  Configuration Access echanism。在本文中，在不会引起误会的情况下，我们混用这两
  个概念，两者是兼容的。

* 内存地址，这个访问的可能是内存，也可能是MMIO

* IO地址，这个是为了兼容传统有独立IO访问指令的处理器设计的。

像鲲鹏这样的处理器并不使用IO指令，所以IO地址空间也转化为MMIO的空间了。

下面是使用鲲鹏920的泰山服务器Linux 5.0内核启动时打印的IO空间对内存空间的映射：::

        Remapped I/O 0x00000000efff0000 to [io  0x0000-0xffff window]
        
代码在drivers/acpi/pci_root.c:acpi_pci_root_remap_iospace()中。它给出了IO地址
映射为MMIO地址的具体参数。

ECAM空间是分配给PCIe控制器的物理地址的一部分，系统可以选择有一个或者多个ECAM空
间。一般可以认为一个ECAM空间就代表这一套总线结构，如果ECAM空间放在一起，就是一
个RC，如果有多个独立使用，就认为有多个RC。这是个平台相关的设计。

PCIe控制器先用ECAM空间来保证CPU可以找到每个设备，然后再配置每个设备的其他地址。
为了从ECAM中定位到设备，从PCI开始就引入了一个Bus-Device-Function的概念，用来区
分地址上的不同设备：

* Bus：网桥的编号，用于唯一标识系统中的总线

* Device：EP的编号，用于标识一个网桥上的一个设备

* Function：EP内一个独立的功能的编号，这用于一个硬件有多个功能的情形，比如一张
  同时支持Ethernet和RoCE的网卡，就包含两个Function了。

Bus-Device-Function简称BDF，可以唯一定位一个设备，一般用b:d.f这种格式表示。把
BDF和ECAM的首地址组合起来，我们就可以唯一定位一个设备的配置空间：

.. figure:: ecam_address.svg

所以，如果我们知道BDF，和ECAM的首地址，我们就可以访问一个设备的配置空间——如果这
个设备存在的话。

我们用PCIe的一个例子看看具体的BDF是如何指配的。下图给出这样一个示例：

.. figure:: pci_bus_id_allocation.svg

由于PCIe是个P2P的总线，网桥内部实际是报文的重新调度，而没有原来PCI总线的意义了
，PCIe标准虚拟化地认为内部其实包含多个总线控制器。控制器也是一个设备，这个设备
的上游总线称为Primary Bus，下游总线称为Secondary Bus。

这样对于一个ECAM空间，软件总可以从Bus 0开始扫描和设置所有的设备。下面是一个过程
的示例：

1. 访问0:0.0，0:1.0, 0:2.0……的配置空间，看能否读到其中的Vendor寄存器，这样我们
   就可以刺探到这个设备是否真实存在。如果设备存在，而且类型是个EP，这个设备就
   找到了。如果这个设备又是一个总线控制器，我们进入总线设置的过程。
   
2. 假设这个总线控制器的BDF=0:x.0，根据约定，我们设置它的Primary是0，Secondary
   是我们要指派的总线号，我们分配1给它，我们就又得到一个总线1，我们可以用第一步
   一样的方法扫描1:0.0, 1:1.0, 1:2.0……得到这条总线上的设备或者总线控制器。

3. 等我们深度优先扫描完一条总线，我们也知道每个网桥的Sub Ordinary应该是多少了，
   把这个结果配置上，我们就得到RC中所有总线对象的配置空间的地址了。之后的问题是
   怎么访问这些空间的问题而已。

配置空间的格式如下：

.. figure:: pci_config_space.svg

PCI和PCIE对每个配置空间预留的大小是不同的，但它们的头部都是一样的。

除了ECAM空间，现在只剩下设备本身的IO地址或者MMIO地址问题了。由于我们已经有了所有
设备和网桥的配置空间，只要软件对分配给这个总线控制器的物理空间进行分配，然后写到
对应设备的BAR寄存器，Base Address Register，中即可。而网桥需要配置哪部分地址需要
下发给它的下游，就可以支持这个通讯。

要注意的是，地址请求不但可以从PCIe空间之外的其他设备发起，也可以从PCIe空间之内
的设备发起。

PCIe总线扫描过程可以由BIOS完成，也可以由操作系统完成。对于服务器来说，无论操作
系统是否会进行PCIe总线扫描，它都必须先进行一次扫描，否则它就无法访问这些设备（
比如磁盘）完成启动过程了。在基于ACPI接口和操作系统通讯的环境中，BIOS会在ACPI表
中保留它扫描的结果，操作系统直接把这些设备当做总线设备使用就可以了。但操作系统
完全也可以选择放弃它扫描的结果，重新按自己的策略进行扫描和地址分配。鲲鹏920采用
的是前一种策略。

鲲鹏920的实际和虚拟PCIe接口
---------------------------

鲲鹏的920的每个SICL中包含一个PCI_ICL提供PCIe接口，同时在每个主要的片上设备中嵌入
PEH和PBU提供PCIe的会话层响应，从总线访问接口看来，这些设备都连在同一个RC上。

鲲鹏920在每个ICL中内置了一些PEH或者PBU单元，在会话层提供PCIe的配置和访问语义。

        | PEH
        | PCI Endpoint Header，是嵌入到每个鲲鹏920内部设备上的PCI EP模拟单元

        | PBU
        | PCI Bridge Unit，是嵌入到鲲鹏920内部设备中用于模拟PCI网桥的单元

这个原理图示如下：

.. figure:: kp920_pci_vpci_arch.svg

整个系统采用但RC结构，总线的DAW机制提供这个地址控制功能。鲲鹏920为ECAM保留256MB
的空间，这个空间内的地址靠DAW机制转发给不同的总线Station，发到PCIe控制器或者PEH
，PBU上。BAR空间则按既定的要求按Station进行分配，这部分分配算法由BIOS控制，最终
通过ACPI的DSDT表表达给操作系统，之后所有设备在操作系统一侧都表现为PCIe设备了。

中断处理
---------

IO虚拟化
--------
todo

