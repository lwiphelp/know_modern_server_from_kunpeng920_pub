.. Copyright by Kenneth Lee. 2020. All Right Reserved.

综述
====

介绍
----
RAS是服务器区别于一般PC的基本能力之一。它是Reliability，Availability和
Serviceabilty的缩写。表示这台服务器的在功能上的可信赖的程度。

RAS的三个要求强调了这种“信赖”的三个不同方面。其中：

Reliability是可靠性，主要强调服务器的输出结果是“对”的。不能出现1+1等于3这样的
情况。这一方面是设计和质量保证的要求，另一方面是运行中要不断进行检查的要求。
当我们谈RAS的时候，主要强调的是后者。换句话说，RAS强调的是：即使你已经做了正确
的设计，你还需要提供这之外额外的手段去检查这个过程是正确的。比如说，你的电路逻
辑可能都是正确的，但中间发生了强电磁干扰，导致你有一个门电路翻转了，你输出的结
果仍有可能是错的，RAS强调的是你必须有额外的手段把这种问题发现出来。

Availability是可用性，表示设备能提供服务的能力，主要强调这个服务的存在。这通常
用MTBF来衡量，表示“在我想使用这个服务的时间内，设备有多少时间是可以提供这个服
务器的”。大部分部件都是会坏的，比如电源，用大量的设备，24小时不间断使用，总会
有部分设备的电源会损坏的，损坏后需要维修，替换，这中间，这个服务就叫“不可用”。
要延长这个MTBF，就需要使用更可靠的单个器件，或者提供设备冗余，比如双电源，这样
，即使其中一个电源损坏了，另一个电源仍可以工作，MTBF就不会减少。

        | MTBF
        | Mean Time Between Failure，平均故障间隔时间，单位是小时。

Serviceabilty是可服务性，表示设备被修复的能力，它通常可以用于提高
Availability。比如某条内存DIMM条损坏了，有Serviceabilty能力的设备可能可以在运
行中直接隔离这条内存条，提供动态插拔的能力，维护人员就可以在设备工作的情况下完
成对内存条的替换。其他提供日志，告警，让维护人员更早发现，更容易定位问题，从而
提前修复问题，这些都属于可服务型考虑的范围。

所以，RAS重视的是服务器在R-A-S三种能力上的结果，这个结果首先是从基本功能上体现
的，但当我们谈到RAS特性的时候，其实更关心的这些基本功能之外做的“额外”设计。因
此，比如故障注入，也是RAS的需求之一。因为我们可以用这种方法模拟一种故障，测试
软件方案的响应能力。这本身并不能提升RAS的效果，但这仍是RAS的基本需求。

在敏感的场合，比如部分关键的金融服务，车辆控制等，人们对服务器的RAS的要求是极
高的，为了提供这样的可靠性，几乎每个服务器部件都有冗余备份。这种备份可以涵盖从
电源，存储，网络到CPU，ALU，内存，乃至总线等各个方面。从而保证设备在任何时候都
可以提供服务。

有些场合，甚至备份也是不足的，比如，有些火车调度系统，会使用三路独立的计算系统
然后在输出的时候通过三路投票决定使用最后的决策。

所以这个问题直观上很难究诘，理论上当然有很多数学模型可以进行一定程度上进行推演
，但产品的应用环境千变万化，所以，工程上，特别是在数据中心的工程上，都是有问题
解决问题，并没有一个严格的方法说明RAS必须如何做。

从这个角度说，鲲鹏920作为鲲鹏系列产品的第一代，RAS实际上还有很长的路要走的。现
在它提供的主要是其他服务器也会提供的基本功能。

一个基本的考量是，它会给几乎所有有缓存和有通讯链路的位置都加上检错或者纠错码。
这种位置包括而不限于：

* L1/2/3 Cache （L3包括Tag和Data）
* DDR/DDRC（HHA）
* MMU/SMMU
* GIC
* IO设备内部
* 所有通讯设施的链路层协议

        .. todo：内存巡检要不要加进来？待调查

纠错码本质就是检错码，只是在跳变的位数少的时候就可以恢复原始数据，跳变的位数太
多的时候只能纠错而已。所以，体现在软件上，RAS报告主要是三种：

1. 已经纠正的错误：报告这个错误主要是为了让用户提前预防
2. 未能纠正但可干涉的错误：报告这个错误主要是为了系统软件进行响应
3. 未能纠正也不可干涉的错误：报告这个错误主要是为了系统软件中止服务以便止损

从这三个报告类型上，读者也许可以注意到：数据中心场合中，止损，阻止错误的传播是
第一位的，地位比提供继续工作这个目标更大。因为服务器异常不能工作了，只是不能提
供服务，但如果允许出了错的数据被使用下去，这个错误就可能被指数式传播出去，导致
整个系统的数据都不可信了。

ACPI的APEI标准也从如何处理的角度分成三种类型：

* Corrected
* Recoverable
* Fatal

PCIe标准的AER也对应分了三类：

* Correctable
* Non-fatal
* Fatal

这些定义都相对接近，但不完全重合。鲲鹏920在处理的时候对按自己的方式进行分类，
然后在根据具体的处理需要，汇报到不同的接口上。

RAS是个针对性强而且自由度非常高的设计，每个部件有不同的设计实践，整机的设计标
准一般体现在如何报告上，这包括ARMv8的RAS扩展，ACPI的相关接口定义，以及具体操作
系统的报告要求。按本书的写作策略，我们后面的描述聚焦在设计选择上，尽量不复述这
些标准的具体内容，如果读者关心系统，可以查询相关的标准文本。


关于RAS的一些基本概念
---------------------
讨论RAS和质量问题的时候，我们常常谈到三个很接近的概念：

* Fault（缺陷）
* Error（错误）
* Failure（失效）

缺陷是固有的，是现实和主观的预期不一致的问题，是出问题的原始原因。比如我预期我
某个地方应该用一个乘法，但我写错了，写成了除法，这是一个错误。电磁风暴导致硬件
一个位跳变了，这也是一个缺陷。有缺陷不一定就导致机器不能用了，比如我乘法写成了
除法，如果我用的乘数一直都是1，我从来不用这个计算单元，或者我有纠错错误，这个
缺陷也不一定引起问题。

错误是实际发生的现实和预期不一致的问题。比如前面提到这个乘法写成了除法，如果我
确实调用了这个计算单元，而且乘数用的是2，这就产生了一个错误。

错误不一定最终表现出来，也不一定表现为这个错误直接描述出来的样子。还是前面这个
例子，计算单元发生了错误，最终可能表现为电脑的屏幕不亮，这个不亮，就是一种“失
效”，失效是最终使用者可以感知的问题。

综合来说，缺陷引起了错误，错误在系统中传播，最终呈现为一种失效。RAS的目的，是
发现缺陷的位置，抑制错误的传播，减少系统的失效。

这三个概念，在很多上下文中是可以有交叉的，本质上它们都是“错误”，只是看从什么角
度来说而已。比如电路失效导致DDR内存被存入一个错误的数据，这从DDR的角度可以把缺
陷归因于某个三极管，但从DDR控制器的角度，这个缺陷就是DDR触发的。所以分清这三个
概念，主要还是要解决前面提到的“传播”问题。

当我们检测到一个错误了，这个错误有可能就发现在检测点上。比如我们在内存中写入一
个值，同时存入了它的ECC，等我们读出来的时候，发现ECC检查错误，这个错误的传播范
围就仅在这个位置上。只要我们不要让它传播，这个错误的范围就是有限的。但如果我们
没有ECC检查，或者ECC检查报告的时间晚了，数据可能就会被用于计算其他数据，等发现
成片数据之间不能自恰的时候，我们已经没有办法控制错误的范围了，这种错误，我们称
为“隐式传播”，隐式传播的数据基本上不可恢复，甚至整机关闭都不一定能恢复。是我们
要尽量避免的，但这种错误甚至可能来之软件在Bug，它并不能彻底避免。

ARMv8的RAS扩展从这个角度把这种需要干涉的错误分为四种级别：

* Uncontainable：可能已经隐式传播了，这是最坏的情况
* Unrecoverable：没有隐式传播，但也没有办法恢复了
* Recoverable：没有隐式传播，还可以恢复，但单元内部的状态已经被污染，必须通过
  中止VM或者进程的方式才能保证数据安全。
* Restartable：单元内部的状态没有被污染，只需要重做一次操作即可

为了把这些错误的报告控制在一定的范围内，ARM RAS扩展引入一个新的栅栏指令，ESB。
程序发出顺序的，栅栏以前的指令引起的所有Containable的指令产生的异常，都隔离在
ESB指令之前，即使是超标量流水线也不能越过这个栅栏，就可以把这类错误现在在一段
程序之内（比如一个虚拟机之内），如果没有发生隐式传播，这个问题都可以通过栅栏
保护，但如果数据已经通过网络等手段传递出去，这个保护也是没有办法的。当然，这个
可能性已经限制得比较小了。


鲲鹏920 RAS总体框架结构
-----------------------

鲲鹏920的系统包括，检测，收集，报告三个部分，示意如下：

        .. figure:: kp920_ras.svg

各个检测装置发现异常后，根据类型通过各自的通讯通路报到计算子系统或者独立的IMU
子系统。IMU是个独立系统，收集的又都是不需要CPU干预的错误，它直接写入ACPI APEI
标准的内存数据结构中即可。CPU一侧则复杂得多，如果是外设自身的错误，按PCIE的AER
标准，分设备进入不同的中断处理程序。如果是计算子系统内部的错误，这按ARM的RAS标
准作为SEA（同步）和SEI（异步）方式报告（具体是SEA还是SEI，取决于具体的细节，比
如L2C fetch可能报的是SEA，但如果是store或者snoop，可能报的是SEI）。

所有报告给CPU的错误都首先是异常或者中断，鲲鹏920按ARM RAS的安全固件优先策略，
先把报告都发到EL3，安全固件直接把数据收集了，和IMU一样写入AER表。然后根据是否
需要操作系统干预，写一个CPLD逻辑，再产生一个中断给CPU，根据虚拟机的设计，转由
EL2分配给虚拟机或者直接由Host OS Kernel处理：（todo：未确定同步异常如何传递进去）。

        .. figure:: cpu_ras_handling.svg

todo：EDAC的处理

APEI
-----
todo：

todo：Linux上查看鲲鹏错误的示例。


.. vim: fo+=mM tw=78
