.. Copyright by Kenneth Lee. 2020. All Right Reserved.

综述
====

介绍
----
RAS是服务器区别于一般PC的基本能力之一。它是Reliability，Availability和
Serviceabilty的缩写。表示这台服务器的在功能上的可信赖的程度。

RAS的三个要求强调了这种“信赖”的三个不同方面。其中：

Reliability是可靠性，主要强调服务器的输出结果是“对”的。不能出现1+1等于3这样的
情况。这一方面是设计和质量保证的要求，另一方面是运行中要不断进行检查的要求。
当我们谈RAS的时候，主要强调的是后者。换句话说，RAS强调的是：即使你已经做了正确
的设计，你还需要提供这之外额外的手段去检查这个过程是正确的。比如说，你的电路逻
辑可能都是正确的，但中间发生了强电磁干扰，导致你有一个门电路翻转了，你输出的结
果仍有可能是错的，RAS强调的是你必须有额外的手段把这种问题发现出来。

Availability是可用性，表示设备能提供服务的能力，主要强调这个服务的存在。这通常
用MTBF来衡量，表示“在我想使用这个服务的时间内，设备有多少时间是可以提供这个服
务器的”。大部分部件都是会坏的，比如电源。同时使用大量的设备，24小时不间断使用
，总会有部分设备的电源会损坏的，损坏后需要维修，替换，这中间，这个服务就叫“不
可用”。要延长这个MTBF，就需要使用更可靠的单个器件，或者提供设备冗余，比如双电
源，这样，即使其中一个电源损坏了，另一个电源仍可以工作，MTBF就不会减少。

        | MTBF
        | Mean Time Between Failure，平均故障间隔时间，单位是小时。

Serviceabilty是可服务性，表示设备被修复的能力，它通常可以用于提高
Availability。比如某条内存DIMM条损坏了，有Serviceabilty能力的设备可能可以在运
行中直接隔离这条内存条，提供动态插拔的能力，维护人员就可以在设备工作的情况下完
成对内存条的替换。其他提供日志，告警，让维护人员更早发现，更容易定位问题，从而
提前修复问题，这些都属于可服务性考虑的范围。

所以，RAS重视的是服务器在R-A-S三种能力上的结果，这个结果首先是从基本功能上体现
的，但当我们谈到RAS特性的时候，其实更关心的这些基本功能之外做的“额外”设计。因
此，比如故障注入，也是RAS的需求之一。因为我们可以用这种方法模拟一种故障，测试
软件方案的响应能力。这本身并不能提升RAS的效果，但这仍是RAS的基本需求。

在敏感的场合，比如部分关键的金融服务，车辆控制等，人们对服务器的RAS的要求是极
高的，为了提供这样的可靠性，几乎每个服务器部件都有冗余备份。这种备份可以涵盖从
电源，存储，网络到CPU，ALU，内存，乃至总线等各个方面。从而保证设备在任何时候都
可以提供服务。

有些场合，甚至备份也是不足的，比如，有些火车调度系统，会使用三路独立的计算系统
然后在输出的时候通过三路投票决定使用最后的决策。对于这样的系统，时间也是决策是
否成功的要素，所以，不能等待备份，必须有手段保证最后的决策按时输出。

所以这个问题直观上很难致诘，理论上当然有很多数学模型可以进行一定程度上进行推演
，但产品的应用环境千变万化，所以，工程上，特别是在数据中心的工程上，常常都是有
问题解决问题，并没有一个严格的方法说明RAS必须如何做。

从这个角度说，鲲鹏920作为鲲鹏系列产品的第一代，它的RAS实际上还有很长的路要走的。
因为完善的RAS功能需要长期、大量应用的支持才能实现。现在它提供的主要是其他服务
器也会提供的基本功能。

在设计上，鲲鹏920一个基本的考量是，它会给几乎所有有缓存和有通讯链路的位置都加
上检错或者纠错码。这种位置包括而不限于：

* L1/2/3 Cache （L3包括Tag和Data）
* DDR/DDRC（HHA）
* MMU/SMMU
* GIC
* IO设备内部
* 所有通讯设施的链路层协议

        .. todo：内存巡检要不要加进来？待调查

纠错码本质就是检错码，只是在跳变的位数少的时候就可以恢复原始数据，跳变的位数太
多的时候只能纠错而已。所以，体现在软件上，RAS报告主要是三种：

1. 已经纠正的错误：报告这个错误主要是为了让用户提前预防不可靠的部件
2. 未能纠正但可干涉的错误：报告这个错误主要是为了系统软件进行响应
3. 未能纠正也不可干涉的错误：报告这个错误主要是为了系统软件中止服务以便止损

从这三个报告类型上，读者也许可以注意到：数据中心场合中，止损，阻止错误的传播是
第一位的，地位比提供继续工作这个目标更大。因为服务器异常不能工作了，只是不能提
供服务，但如果允许出了错的数据被使用下去，这个错误就可能被指数式传播出去，导致
整个系统的数据都不可信了。

ACPI的APEI标准也从如何处理的角度分成三种类型：

* Corrected
* Recoverable
* Fatal

PCIe标准的AER也对应分了三类：

* Correctable
* Non-fatal
* Fatal

这些定义都相对接近，但不完全重合。鲲鹏920在处理的时候对按自己的方式进行分类，
然后在根据具体的处理需要，汇报到不同的接口上。

RAS是个针对性强而且自由度非常高的设计，每个部件有不同的设计实践，整机的设计标
准一般体现在如何报告上，这包括ARMv8的RAS扩展，ACPI的相关接口定义，以及具体操作
系统的报告要求。按本书的写作策略，我们后面的描述聚焦在设计选择上，尽量不复述这
些标准的具体内容，如果读者关心系统，可以查询相关的标准文本。


关于RAS的一些基本概念
---------------------
讨论RAS和质量问题的时候，我们常常谈到三个很接近的概念：

* Fault（缺陷）
* Error（错误）
* Failure（失效）

缺陷是固有的，是现实和主观的预期不一致的问题，是出问题的原始原因。比如我预期我
某个地方应该用一个乘法，但我写错了，写成了除法，这是一个人为引入的缺陷。电磁风
暴导致硬件一个位跳变了，这也是一个外部干扰造成的缺陷。有缺陷不一定就导致机器不
能用了，比如我乘法写成了除法，如果我用的乘数一直都是1，或者我从来不用这个计算
单元，或者我有纠错设计，这个缺陷也不一定引起问题。

错误是实际发生的现实和预期不一致的问题。比如前面提到这个乘法写成了除法，如果我
确实调用了这个计算单元，而且乘数用的是2，这就产生了一个错误。

错误不一定最终表现出来，也不一定表现为这个错误直接描述出来的样子。还是前面这个
例子，计算单元发生了错误，最终可能表现为电脑的屏幕不亮，这个不亮，就是一种“失
效”，失效是最终使用者可以感知的问题。

综合来说，缺陷引起了错误，错误在系统中传播，最终呈现为一种失效。RAS的目的，是
发现缺陷的位置，抑制错误的传播，减少系统的失效。

这三个概念，在很多上下文中是可以有交叉的，本质上它们都是“错误”，只是看从什么角
度来说而已。比如电路失效导致DDR内存被存入一个错误的数据，这从DDR的角度可以把缺
陷归因于某个三极管，但从DDR控制器的角度，这个缺陷就是DDR触发的。所以分清这三个
概念，主要还是要解决前面提到的“传播”问题。

当我们检测到一个错误了，这个错误有可能就发现在检测点上。比如我们在内存中写入一
个值，同时存入了它的ECC，等我们读出来的时候，发现ECC检查错误，这个错误的传播范
围就仅在这个位置上。只要我们不要让它传播，这个错误的范围就是有限的。但如果我们
没有ECC检查，或者ECC检查报告的时间晚了，数据可能就会被用于计算其他数据，等发现
成片数据之间不能自恰的时候，我们已经没有办法控制错误的范围了，这种错误，我们称
为“隐式传播”，隐式传播的数据基本上不可恢复，甚至整机关闭都不一定能恢复。是我们
要尽量避免的，但这种错误甚至可能来自软件的Bug，它并不能彻底避免。

ARMv8的RAS扩展从这个角度把这种可能需要干涉的错误分为四种级别：

* Uncontainable：可能已经隐式传播了，这是最坏的情况
* Unrecoverable：没有隐式传播，但也没有办法恢复了
* Recoverable：没有隐式传播，还可以恢复，但单元内部的状态已经被污染，必须通过
  中止VM或者进程的方式才能保证数据安全。
* Restartable：单元内部的状态没有被污染，只需要重做一次操作即可

为了把这些错误的报告控制在一定的范围内，ARM RAS扩展引入一个新的栅栏指令，ESB。
程序发出顺序的，栅栏以前的指令引起的所有Containable的指令产生的异常，都隔离在
ESB指令之前，即使是超标量流水线也不能越过这个栅栏，就可以把这类错误现在在一段
程序之内（比如一个虚拟机之内），如果没有发生隐式传播，这个问题都可以通过栅栏
保护，但如果数据已经通过网络等手段传递出去，这个保护也是没有办法的。当然，这个
可能性已经限制得比较小了，至少给软件解决方案留下了一个可以进行自我保护的基础。


鲲鹏920 RAS总体框架结构
-----------------------

鲲鹏920的系统包括，检测，收集，报告三个部分，示意如下：

        .. figure:: kp920_ras.svg

各个检测装置发现异常后，在执行通路上的核内错误可以直接产品Data Abort异常（SEA
），否则就形成中断上报。根据中断类型，这种错误可以报给CPU或者IMU。

        | SEA和SEI
        | SEA和SEI都是System Error类的错误报告机制。SEA是同步报告，
        | 会立即中止指令的执行。这有利于立即修复错误，而SEI是异步报告，
        | 通过中断子系统上报。计算子系统内部的错误，根据不同的情形，
        | 有可能使用不同的报告方式的。比如L2C fetch可能报的是SEA，
        | 但如果是L2C store或者snoop，可能报的是SEI）。

IMU是个独立系统，收集的又都是不需要CPU干预的错误，它直接写入ACPI APEI标准的内
存数据结构中即可。CPU一侧则复杂得多，如果是外设自身的错误，按PCIE的AER标准，分
设备进入不同的中断处理程序。

所有报告给CPU的错误都首先是异常或者中断，鲲鹏920按ARM RAS的安全固件优先策略，
先把报告都发到EL3，安全固件直接把数据收集了，和IMU一样写入APEI表。然后根据是否
需要操作系统干预，在给EL2或者EL1层转发这个通知。这有两种方法：如果需要种入一个
外部中断，可以通过写一个CPLD逻辑，产生一个不是路由到EL3的中断给CPU，这个中断具体
调度给EL2还是EL1，完全看Hypervisor的调度策略了。如果需要种入一个同步的Data
Abort异常，这更简单，只要在EL3异常返回的时候修改一下返回位置就可以了。

        .. figure:: cpu_ras_handling.svg

APEI
~~~~~

APEI是APCI定义错误处理方法的接口。鲲鹏920的错误（包括外设如AER等错误），都首先
收集到这个数据结构中。它包括很多个互相关联的表格，例如：

* ERST，Error Record Serialization Table，定义保存数据的访问接口
* BERT，Boot Error Record Table，上次死机信息
* HEST/AEST，错误源定义（AEST是ARM的专用版本）
* EINJ，错误注入接口

表格的数据都在内存中，IMU和CPU的EL3共享相关内存，按互斥的方法填写数据。

在Linux内核中，这些接口都实现为drivers/acpi/apei/目录中一个独立的模块，而APEI
本身主要提供虚拟机调用支持，以便这些表格可以直接包含函数调用。

以EINJ表为例，对应的设置代码在drivers/acpi/apei/einj.c中，初始化的时候读表，获
得EINJ表的上下文，然后创建对应的debugfs：::

        static int __init einj_init(void)
        {
                ...

                status = acpi_get_table(ACPI_SIG_EINJ, 0,
                                        (struct acpi_table_header **)&einj_tab);
                ...
                einj_debug_dir = debugfs_create_dir("einj", apei_get_debugfs_dir());

                debugfs_create_file("available_error_type", S_IRUSR, einj_debug_dir,
                                    NULL, &available_error_type_fops);
                debugfs_create_file_unsafe("error_type", 0600, einj_debug_dir,
                                           NULL, &error_type_fops);
                debugfs_create_file_unsafe("error_inject", 0200, einj_debug_dir,
                                           NULL, &error_inject_fops);
                ...
        }

当请求通过debugfs的error_inject发入的时候，error_inject_fops的回调被激活，einj
驱动用Linux的APEI提供的虚拟机调用EINJ表中提供的种入函数：::

        static int error_inject_set(void *data, u64 val)
        {
                ...
                return einj_error_inject(error_type, error_flags, error_param1, error_param2,
                        error_param3, error_param4);
        }

einj_error_inject()最终就是把参数送入虚拟机，进行解释执行。

其他模块通常只是从表格中读数据，简单如BERT的，仅仅就是在初始化的时候把表格读出
来，然后通过ftrace的跟踪函数，把数据写入ftrace的ringbuffer。

复杂一点的比如GHES，注册为平台设备，每个设备注册为一个EDAC的报告者，由EDAC框架
通过ftrace记录在ftrace ringbuffer中。


软件部分方案
-------------

在Linux解决方案中，Corrected Error只是需要记录，这种错误如前所述，都可以通过
ftrace框架直接记录。而其他的错误，如果能处理的，已经由Hypervisor等实体处理了，
如果不能处理的，到了内核，就只能panic。（todo：其实如果发生在进程中，应该也可
以处理的，但现在内核好像没有管）。

这种错误的报告，分散在各个模块，Linux内核通过ftrace的跟踪进行收集。所以，任何
一个模块都可以类似printk一样报告这个错误。而内存类的错误，很大一部分由一个统一
的框架，EDAC进行收集。

EDAC
----
EDAC，Error Detection And Correction，是Linux内核RAS框架的重要组成部分。最早的
时候，它主要用于处理内存错误。后来进行了一些简单的扩展，部分非标准的错误收集，
也统一到这个框架中。鲲鹏920使用GHES进行RAS消息收集，所以不需要任何驱动，就可以
被这个框架的GHES驱动支持。

EDAC包括几个子模块：

* MC：Memory Controller，处理内存相关错误，这就是原来EDAC本身
* Device：这是扩展的，用于一般非标准的报告，比如L2C
* PCI：这个专门用于PCI类的报告

三个框架的核心都是其中提供的edac_check回调，如果硬件自己支持中断通知，可以在报
告中调用这个检查，如果使用EDAC_OPSTATE_POLL模式，框架可以创建workqueue进行定期
检查。edac_check中发现错误，通过edac_mc_handle_error()报告给edac框架，然后通过
内核ftrace框架，写到ftrace的ring buffer中。鲲鹏920不使用这个POLL模式，收集都通
过中断报告。

EDAC也提供debugfs，用于在Kernel层面进行错误注入。

todo：注入的具体方法

RASDAEMON
----------

数据收集在ftrace ringbuffer中，用户态可以通过ftrace进行数据汇总和呈现。一般商
用解决方案会有自己的报告工具，在开放的Linux发行版中，一般集成开源的RASDAEMON。

RASDAEMON的原理很简单，就是从/sys/kernel/tracing中创建一个新的instance，然后开
不同的事件跟踪，比如：

* ras:mc_event
* ras:aer_event
* ras:non_standard_event
* ras:arm_event
* mce:mce_record
* ras:extlog_mem_event
* net:net_dev_xmit_timeout
* devlink:devlink_health_report
* block:block_rq_complete

读出来的数据可以选择写入syslog，用户指定的文件，或者sqlite数据库中。

.. vim: fo+=mM tw=78
