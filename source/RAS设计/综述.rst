.. Copyright by Kenneth Lee. 2020. All Right Reserved.

综述
====

介绍
----
RAS是服务器区别于一般PC的基本能力，它是Reliability，Availability和
Serviceabilty的缩写。表示这台服务器的可信赖的程度。

RAS的三个要求强调了这种“信赖”的三个不同方面。其中，

Reliability是可靠性，主要强调服务器的输出结果是“对”的。不能出现1+1等于3这样的
情况。这一方面是设计和质量保证的要求，另一方面是运行中要不断进行检查的要求。
当我们谈RAS的时候，主要强调的是后者。换句话说，RAS强调的是：即使你已经做了正确
的设计，你还需要提供这之外额外的手段去检查这个过程是正确的。比如说，你的电路逻
辑可能都是正确的，但中间发生了强电磁干扰，导致你有一个门电路翻转了，你输出的结
果仍有可能是错的，RAS强调的是你必须有额外的手段把这种问题发现出来。

Availability是可用性，表示设备能提供服务的能力，主要强调这个服务的存在。这通常
用MTBF来衡量，表示“在我想使用这个服务的时间内，设备有多少时间是可以提供这个服
务器的”。大部分部件都是会坏的，比如电源，用大量的设备，24小时不间断使用，总会
有部分设备的电源会损坏的，损坏后需要维修，替换，这中间，这个服务就叫“不可用”。
要延长这个MTBF，就需要使用更可靠的单个器件，或者提供设备冗余，比如双电源，这样
，即使其中一个电源损坏了，另一个电源仍可以工作，MTBF就不会减少。

        | MTBF
        | Mean Time Between Failure，平均故障间隔时间，单位是小时。

Serviceabilty是可服务性，表示设备在被修复的能力，它通常可以用于提供
Availability。比如某条内存DIMM条损坏了，有Serviceabilty能力的设备可能可以在运
行中直接隔离这条内存条，提供动态插拔的能力，维护人员就可以在设备工作的情况下完
成对内存条的替换。

所以，RAS重视的是服务器在R-A-S三种能力上的结果，这个结果首先是从基本功能上体现
的，但当我们谈到RAS特性的时候，其实更关心的这些基本功能之外做的“额外”设计。因
此，比如故障注入，也是RAS的需求之一。因为我们可以用这种方法模拟一种故障，测试
软件方案的响应能力。这本身并不能提升RAS的效果，但这仍是RAS的基本需求。

在敏感的场合，比如部分关键的金融服务，车辆控制等，人们对服务器的RAS的要求是极
高的，为了提供这样的可靠性，几乎每个服务器的部件都有冗余备份，从电源，存储，网
络到CPU，ALU，内存，乃至总线，都有备份设计，这可以保证任何时候出了错误，都可以
被检测出来，并且可以保持工作以便为修复系统留出时间。

鲲鹏920主要面对数据中心场合，在这种场合中，使用者更关注Reliability，而它的
Availability和Serviceabilty主要是靠多台服务器来提供的。换句话说，在数据中心，
用户更关心数据不要出错，以及出错以后可以让应用知道，而单台服务器本身是否损坏，
这个问题仍然重要，但相对来说不是重点。

所以相应地，鲲鹏920的RAS设计也主要针对这一点，它在所有有本地缓存的地方都增加了
检错或者纠错码，包括而不限于：

* L1/2/3 Cache （L3包括Tag和Data）
* DDR
* DDRC（HHA）
* SMMU
* GIC
* IO设备
* 所有通讯设施的链路层协议

纠错码本质就是检错码，只是在跳变的位数少的时候就可以恢复原始数据，跳变的位数太
多的时候只能纠错而已。所以，体现在软件上，RAS报告主要是两种：

1. 已经纠正的错误
2. 未能纠正的错误

前者的作用主要是要提醒用户这个部件可能已经开始老化需要更换了，后者的作用主要是
告知用户，相关的部件涉及的数据已经不可靠了，需要软件进行隔离或者放弃相关的数据
。

RAS是个针对性强而且自由度非常高的设计，每个部件有不同的设计实践，整机的设计标
准一般体现在如何报告上，这包括ARMv8的RAS扩展，ACPI的相关接口定义，以及具体操作
系统的报告要求。

ARMv8 RAS扩展标准并没有对外公开，而且留下的自由很高，所以我们介绍接口主要还是
聚焦在ACPI等公开接口和920的具体实现上，不会提到这个标准的相关内容。

关于RAS的一些基本概念
---------------------
讨论RAS和质量问题的时候，我们常常谈到三个很接近的概念：

* Fault（缺陷）
* Error（错误）
* Failure（失效）

缺陷是固有的，是现实和主观的预期不一致的问题，是出问题的原始原因。比如我预期我
某个地方应该用一个乘法，但我写错了，写成了除法，这是一个错误。电磁风暴导致硬件
一个位跳变了，这也是一个缺陷。有缺陷不一定就导致机器不能用了，比如我乘法写成了
除法，如果我用的乘数一直都是1，或者我从来不用这个计算单元，这个缺陷也不一定引
起问题。

错误是实际发生的现实和预期不一致的问题。比如前面提到这个乘法写成了除法，如果我
确实调用了这个计算单元，而且用的是2，这就产生了一个错误。

错误不一定最终表现出来，也不一定表现为这个错误直接描述出来的样子。还是前面这个
例子，计算单元发生了错误，最终可能表现为电脑的屏幕不亮，这个不亮，就是一种“失
效”，失效是最终使用者可以感知的问题。

综合来说，缺陷引起了错误，错误在系统中传播，最终呈现为一种失效。RAS的目的，是
发现缺陷的位置，抑制错误的传播，减少系统的失效。

这三个概念，在很多上下文中是可以有交叉的，本质上它们都是“错误”，只是看从什么角
度来说而已。比如电路失效导致DDR内存被存入一个错误的数据，这从DDR的角度可以把缺陷
归因于某个三极管，但从DDR控制器的角度，这个缺陷就是DDR触发的。所以分清这三个概
念，是为了在某个维度上，更好决定错误的处理而已。

从这个角度来看这个问题，我们还可以把各种错误分成几种：

* 被纠正的错误（CE），比如被DDRC通过ECC算法修正的读写行为。

* 可修复的错误（RE），错误被检测出来，但没有被纠正，需要报告CPU采取行动。

* 不可修复的错误（UE），错误已经知道，但无法修复。这可以包括更多复杂的场景，比
  如检测到数据自相矛盾，前面肯定已经发生了错误的隐性传播，但已经无法知道原因，
  也不知道传播的范围有多大，这些都属于UE。

ACPI的APEI标准也从如何处理的角度分成三种类型：

* Corrected

* Recoverable

* Fatal

PCIe标准的AER也对应分了三类：

* Correctable
 
* Non-fatal

* Fatal

这些定义都相对接近，但不完全重合。鲲鹏920在处理的时候对按自己的方式进行分类，
然后在根据具体的处理需要，汇报到不同的接口上。

鲲鹏920 RAS总体框架结构
-----------------------

鲲鹏920的系统包括，检测，收集，报告三个部分，示意如下：

        .. figure:: kp920_ras.svg

todo：分类，内核中分别对RAS，EDAC，AER的处理路径和方法。

APEI
-----
todo：

todo：Linux上查看鲲鹏错误的示例。


.. vim: fo+=mM tw=78
