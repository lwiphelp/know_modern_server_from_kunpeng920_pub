.. Copyright by Kenneth Lee. 2020. All Right Reserved.

通用计算
========

如前所述，鲲鹏920通用计算核基于ARMv8的架构定义设计。ARMv8的指令集在ARMv8的构架
手册上可以查到，我们这里不打算重复那里的内容。我们从软件架构的角度对这个指令集
进行一些理解，结合鲲鹏920的具体实现，让读者看到这个领域的控制要素是什么。

ARMv8使用32位定长指令格式，支持32个通用寄存器，然则每个寄存器要用5位，假如指令
类别，包括指令的各种私有分类指示，用8位，那么一条指令最多可以独立索引4个寄存器。
也可以少索引一些寄存器，把这些寄存器用作立即数，如果所有寄存器都不使用，最大的
立即数索引就只能是24位。

ARMv8的指令分6个大类：

* 00xx 未使用
* 100x 立即数计算，8位操作码，一到两个寄存器，剩下用于立即数
* 101x 分支（条件，无条件），系统行为（比如DSB一类）
* x1x0 内存读写操作
* x101 寄存器计算
* x111 向量和浮点计算

鲲鹏920内置的泰山核使用这些计算单元来实现这些指令：

* LSU：内存访问
* ALU：内部包含多个独立单元
        * ALU/b两个：一般定点运算，支持分支处理
        * ALU一个：一般定点计算，不支持分支计算
        * MDU一个：复杂定点计算（比如乘除法）
* FSU：包含四个独立的不同参数的浮点和向量计算单元

这些计算单元在OoO和流水线的共同作用下，每个Cycle同步或者异步执行。其中FSU和ALU
使用不同的寄存器进行运算，只在内存读入写出的时候和LSU有关系，其他时间基本上可
以和ALU同步使用。这一类的调度机会，就是编译器可以介入帮助的地方。编译器基于“反
正结果是一样就行”的策略，可以重新排布指令的顺序，保证流水线和OoO的效率更高。

我们再深入看看ARMv8的指令的设计细节。它具有这样一些特点：

1. 大部分指令使用寄存器的时候都可以通过flag控制使用寄存器的字长。
2. 如果有不同效果，大部分指令都会有flag处理符号扩展问题。
3. 使用独立的条件寄存器，可以用于进位，跳转等功能，但也有非依赖条件寄存器的版本
   ，比如TBNZ，但因为编码空间问题，地址范围可能在32KB和128M的不同范围内。
4. 支持双寄存器读写
5. 支持原子，Exclusive和Aquire/Relase操作（参考下一章“内存访问模型”）
6. 支持16位指令（压缩）
7. 浮点和向量共寄存器，和通用寄存器独立
8. 支持Cache prefetch
9. 一般定点主要包括：加减，比较，取负，移位，逻辑运算，寄存器迁移，位操作。还
   有一些特殊的指令：
        * EXTR：从两个寄存器中取中间一段
        * 根据条件寄存器决定取寄存器中部分内容
10. 复杂定点包括：
        * 乘除（可以组合一个加减法）
        * CRC32
        * AES, 椭圆计算，SHA1，SHA256
11. 浮点主要是按标准（todo：忘了那个标准了）
12. 向量计算主要是把一般计算用更长的寄存器展开为向量

在ARMv7的时代，大部分指令都带有一个cond条件，用于决定是否执行这个指令，这是一
种优化流水线的方法，但现实是没有多少场合能用起来，所以最终这个设计在ARMv8中已
经被抛弃了。读者也需要应该注意到，在指令设计中，这是常态。包括我们今天使用的
ARMv8，未来也会出现这种抛弃的情况。这不受设计者的意愿和能力所控制，这是被外部
需求驱动的。

如果我们对比一下另一个新兴的开放指令集，RISCV，我们可以看到两者在取舍上的区别
：

todo...

.. vim: fo+=mM tw=78
