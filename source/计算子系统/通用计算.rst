.. Copyright by Kenneth Lee. 2020. All Right Reserved.

通用计算
========

如前所述，鲲鹏920通用计算核基于ARMv8的架构定义设计。ARMv8的指令集在ARMv8的构架
手册上可以查到，我们这里不打算重复那里的内容。我们从软件架构的角度对这个指令集
进行一些理解，结合鲲鹏920的具体实现，让读者看到这个领域的控制要素是什么。

ARMv8使用32位定长指令格式，支持32个通用寄存器，然则每个寄存器要用5位，假如指令
类别，包括指令的各种私有分类指示，用8位，那么一条指令最多可以独立索引4个寄存器。
也可以少索引一些寄存器，把这些寄存器用作立即数，如果所有寄存器都不使用，最大的
立即数索引就只能是24位。

ARMv8的指令分6个大类：

* 00xx 未使用
* 100x 立即数计算，8位操作码，一到两个寄存器，剩下用于立即数
* 101x 分支（条件，无条件），系统行为（比如DSB一类）
* x1x0 内存读写操作
* x101 寄存器计算
* x111 向量和浮点计算

鲲鹏920内置的泰山核使用这些计算单元来实现这些指令：

* LSU：内存访问
* ALU：内部包含多个独立单元
        * ALU/b两个：一般定点运算，支持分支处理
        * ALU一个：一般定点计算，不支持分支计算
        * MDU一个：复杂定点计算（比如乘除法）
* FSU：包含四个独立的不同参数的浮点和向量计算单元

这些计算单元在OoO和流水线的共同作用下，每个Cycle同步或者异步执行。其中FSU和ALU
使用不同的寄存器进行运算，只在内存读入写出的时候和LSU有关系，其他时间基本上可
以和ALU同步使用。这一类的调度机会，就是编译器可以介入帮助的地方。编译器基于“反
正结果是一样就行”的策略，可以重新排布指令的顺序，保证流水线和OoO的效率更高。

我们再深入看看ARMv8的指令的设计细节。它具有这样一些特点：

1. 大部分指令使用寄存器的时候都可以通过flag控制使用寄存器的字长。
2. 如果有不同效果，大部分指令都会有flag处理符号扩展问题。
3. 使用独立的条件寄存器，可以用于进位，跳转等功能，但也有非依赖条件寄存器的版本
   ，比如TBNZ，但因为编码空间问题，地址范围可能在32KB和128M的不同范围内。
4. 支持双寄存器读写
5. 支持原子，Exclusive和Aquire/Relase操作（参考下一章“内存访问模型”）
6. 支持16位指令（压缩）
7. 浮点和向量共寄存器，和通用寄存器独立
8. 支持Cache prefetch
9. 一般定点主要包括：加减，比较，取负，移位，逻辑运算，寄存器迁移，位操作。还
   有一些特殊的指令：
        * EXTR：从两个寄存器中取中间一段
        * 根据条件寄存器决定取寄存器中部分内容
10. 复杂定点包括：
        * 乘除（可以组合一个加减法）
        * CRC32
        * AES, 椭圆计算，SHA1，SHA256
11. 浮点主要是在IEEE Std-754的基础上进行一些补充
12. 向量计算主要是把一般计算用更长的寄存器展开为向量

在ARMv7的时代，大部分指令都带有一个cond条件，用于决定是否执行这个指令，这是一
种优化流水线的方法，但现实是没有多少场合能用起来，所以最终这个设计在ARMv8中已
经被抛弃了。读者也需要应该注意到，在指令设计中，这是常态。包括我们今天使用的
ARMv8，未来也会出现这种抛弃的情况。这不受设计者的意愿和能力所控制，这是被外部
需求驱动的。

如果我们对比一下另一个新兴的开放指令集，RISC-V，我们可以从新发展的指令上看到两
者在取舍上的区别。下面是和The RISC-V Instruction Set Manual Volume I:
Unprivileged ISA 20180801-draft对比的一个总结（纯比较计算单元能力，不考虑体系
结构的区别，我们特定对比前面列出的ARM的特性）：

1. 字长控制的策略和ARM一样
2. 符号扩展策略也和ARM一样
3. 刻意放弃了condition flag，所有的条件都是计算出来的。在ARM上可以先做一个比较
   ，更新condition flag，然后做一个基于condition flag的跳转。而RISCV只提供比较
   并跳转这样的操作。
4. 不支持双寄存器读写。这是个微架构的取舍，一种可能的认识是双寄存器读写的指令
   ，在微架构上不见得比发出两条读写指令更快。所以RISCV并不急着支持这条指令。
5. 支持原子，其中Load Reserved/Store Conditional指令对应ARM的Exclusive指令
6. 变长指令支持，主要指令是32位的，但也支持更短的16位指令，和更长的指令
7. 向量指令有独立寄存器，和浮点和通用寄存器都独立
8. 不支持Cache prefetch。这个指令背后的观点可以是，软件指定prefetch的效果不能
   证明比如比硬件自动判断更优。
9. 支持加减，移位，逻辑运算。但寄存器迁移靠加减指令解决，位操作还在定义中，没
   有EXTR等数据提取指令，没有比较指令（应为比较和跳转一体了）
10. 复杂定点支持乘除，但还没有压缩、加解密等专用指令
11. 浮点完全使用IEEE Std-754的定义
12. 向量计算的策略和ARM的定义类似

可以看到，其实现在指令集基本上功能已经比较单一了，主要的优化其实主要还是在做减
法，但能否减成功，还是看应用的发展。

.. vim: fo+=mM tw=78
