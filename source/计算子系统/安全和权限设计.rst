.. Copyright by Kenneth Lee. 2020. All Right Reserved.

权限设计
========

权限设计给予不同的软件部件访问整个服务器不同的资源的能力。这种能力从主控CPU开
始，为不同的软件部件的设定身份，然后再把不同的硬件资源的使用能力赋予这些角色。

鲲鹏920的主控CPU服从ARMv8的标准，先控制了主控CPU的软件角色，再由这些决策分配其
他计算或者IO单元的访问权限，从而让服务器的管理员可以基于不同权限的软件对象把设
备的控制权分发出去。

鲲鹏920的主CPU核包括4个特权级2个安全模式，我们先从CPU的控制开始理解这个安全模
型：

CPU特权级
---------

CPU特权级是CPU的一种工作状态，CPU被切换到这个工作状态，才能使用CPU特定的功能。

大部分通用芯片都使用这样一种管理结构：CPU启动的时候先进入最高特权级，这个特权
级的软件设定各种资源的可访问权限，把下一个特权级可以使用的资源放进独立的隔离
空间，设定本特权级的调用入口，然后放权进入下一个特权级。这样，最初在这个高特权
级的部件就拥有控制本层的权限了，图示如下：

        .. figure:: cpu_privilege.svg

鲲鹏920包括4个特权级，这兼容ARMv8的定义，但ARMv8对实现多少个特权级是可选的，鲲
鹏是定义允许的所有特权级了。这一特点在后面的叙述中会经常出现，我们会聚焦到介绍
鲲鹏的实现，请读者注意。

鲲鹏920包含的4个特权级是：

* EL0：用户特权级，用于运行用户程序
* EL1：内核特权级，用于运行操作系统内核
* EL2：Hypervisor特权级，用于运行虚拟机管理器
* EL3：安全管理特权级，用于运行安全管理器

所以一种基本的鲲鹏920启动过程是这样的：

* 芯片复位，CPU进入EL3模式，从既定的入口开始执行代码，由Boot Loader软件控制

* Boot Loader初始化，设定后EL3的进入入口，加载Hypervisor，降低权限到EL2，运行
  Hypervisor

* Hypervisor初始化，加载操作系统内核，降低权限到EL1，运行操作系统内核

* 操作系统内核初始化，加载第一个进程，进入调度，调度到这个进程的时候，降低权限
  到EL0，运行用户进程

这样一个结构，先被在高特权级的初始化的软件控制了下一级的资源，下一级要访问这些
资源就只能发起越级调用，这个控制权就回到高级的软件部件上了。

另一种回到高特权级的方式是外部中断，这个控制全仍由高一级的特权级控制，高特权级
控制什么中断在本级处理，则无论当前CPU被什么权限的软件部件控制，发生中断了，CPU
都会回到指定特权级的固定入口，把控制权交还给这个软件部件。

高特权级的软件可以创建多个低特权级的软件实例，每次进入高特权级的软件的时候，它
都可以决定具体把哪个实例投入运行。这样，即使只有一个CPU核，我们都可以有多个安全
区，虚拟机或者进程。图示如下：

        .. figure:: multi_software_instances.svg

尽管在交流中我们会说“有多个软件实例运行在某个CPU上”，但其实在某个时刻，CPU只会
处于某个软件部件的执行状态上。

        | SMT
        | todo

但如果我们有多个CPU核或者SMT，每个CPU核都可以运行在某个软件部件的执行状态上：

        .. figure:: multi_software_instances_multi_cpus.svg

当然，以上只是理论，在实际中会有不同的变化，我们看一个典型的实际例子。一种常见
的软件组合是这样的：

* Boot Loader：ATF，UEFI，Grub

* 操作系统内核：Linux Kernel

* 用户程序：glibc为基础的用户应用

其中ATF是ARM Trust Fireware，提供基本的安全调用封装，大部分常见都会对这个软件
进行修改，以配合自己的解决方案。

UEFI是标准的BIOS软件，完成硬件最基本的初始化

Grub是二级Boot Loader，它的作用是降低UEFI的复杂度，做一些更高级的初始化。很多
定制化的方案甚至可以没有它，UEFI也是可以直接启动Linux Kernel的。但有了Grub，可
以：

* 做多选菜单：选择启动不同的Linux Kernel
* 支持更多的文件系统：Linux Kernel保存在文件系统中，Boot Loader要读这个文件就
  需要认识对应的文件系统格式
* 修改启动参数等Grub已经完成得很成熟的功能，等等

现代软件方案的常态，很多时候不是什么方案是“最合理”的，而是什么方案是“开发成本
最低”和“最成熟”的。

基于这个方案启动鲲鹏920，首先是EL3，进入的是ATF，之后权限降低到EL2，进入UEFI，
Grub，然后启动Linux Kernel，按虚拟化模式，这这有可能在EL1也有可能在EL2（后面单
独介绍），Linux Kernel根据虚拟化方案的模式，决定继续停留在EL2还是主动降权到EL1
，完成内核的初始化，最后调度init进程投入运行，再度降权到EL0。

这个方案仍和前面介绍原理是接近的，但并不完全一致。

Hypervisor模式
``````````````
GNU/Linux有两个典型的虚拟化解决方案，Xen和KVM，分别代表两种不同的Hypervisor设
计方案，有人把这两种模式分别称为type1和type2模式。

Type1模式，以Xen为代表，Hypervisor是一个独立的部件，仅完成虚拟机调度等基本功能
，然则它不包含驱动程序，不能访问IO设备，这需要使用其中一个OS用作IO驱动的代理，
在Xen中，这个OS称为Dom0 OS。这种工作方式的优势在于Hypervisor比较简单，更容易控
制Hypervisor的质量，缺点是IO需要经过调度到Dom0，有些应用场景会影响性能。

Type2模式，以KVM为代表，Hypervisor是OS的一部分，用Xen的概念来理解，第一个启动
的Linux Kernel就是Dom0和Hypervisor。这种工作方式的优劣势和Type 1是相反的。

另外，Type2需要硬件一定程度的支持，因为EL1可以访问的资源，可能是这个虚拟机专有
的，如果OS Kernel和Hypervisor是一体的，当内核工作在EL2的时候，可能无法访问EL1
的部分专有寄存器。ARMv8的VHE，Virtual Host Extension，是为解决这个问题而设计的
，鲲鹏920支持这个扩展。

所以，在鲲鹏920上，如果使用Xen，Grub会启动Xen的Hypervisor，Xen工作在EL2，然后
降低权限到EL1，在跳转到Linux kernel。如果使用KVM，Grub直接启动Linux Kernel，
Kernel会工作在EL2模式。

        | VHE
        | todo：Virtual Host Extension

相关的Linux代码，以主线5.5为例，ARM64构架的内核入口在
arch/arm64/kernel/entry.S:_text中，（arch/arm64/kernel/vmlinux.lds.S定义了这个
入口），如果是KVM的第一个系统，内核处于EL2。

        | Linux Kernel主线
        | Linux Kernel的主线是指Linus Torvards个人管理的分支，
        | 这个分支以2个半月到三个月为一个周期，接受下游分支的推送，
        | 如果这些推送的特性最终通过测试和评审等，
        | 就会称为新版本的一部分。当前常见的几乎所有的Linux Kernel分支，
        | 都是以这个主线为基础的。被这个分支接受的特性，
        | 才会被认为是被主流方案所接受的特性。

_text会首先调用el2_setup，判断当前的EL等级，并根据是否是能了VHE，决定使用EL2模
式的Kernel还是EL1模式的Kernel。之后，它会完成C语言运行环境的准备，进入所有平台
共用的start_kernel()入口，进行每个子系统的初始化，最后创建0号进程，在内核中调
用execl系统调用，创建新的进程，让调度流程把CPU切换到EL0状态运行对应的进程了。

而多核的情形是单核的扩展，BIOS仅使用0核工作，执行过程走到Linux Kernel后，_text
的执行仍依赖0核进行。0核进入start_kernel()后，会进而调用setup_arch()，
smp_init_cpus()，到这里为止，内存中提供给各个非0号CPU的数据已经准备完成，只要
给每个CPU核发送启动命令，就可以启动对应的核，这些核开始进入
arch/arm64/kernel/entry.S:secondary_entry，和0核类似，也调用el2_setup，完成EL2
的准备，进入EL1，进入C的入口：arch/arm64/kernel/smp.c:secondary_start_kernel，
最后进入cpu_startup_entry()，进入Idel状态，这样有其他进程调度到本CPU的时候，它
同样可以进入EL0状态。

        | SMP 是 Symmetric Multi-Processing 的缩写。
        | 不同的场合可能有不同的应用，但大部分这样的系统，
        | 都是使用多个共享相同内存地址空间的处理器构成服务器的计算子系统。
        | 在这样的系统中，主要的计算核都共享相同的内存空间，并且任意计算核之间访问共享
        | 地址空间的代价相当。
        | 所以在这样的系统上，通常采用这样一种软件策略：
        | 先启动第一个核（0核），由这个核设定内存中所有必须的数据结构，
        | 然后再由0核启动其他核，从而让整个系统进入运行。
        | 与之相应的，NUMA (Non-Uniform Memory Access)指称这样一种系统，不同的计算核
        | 虽然也共享相同的地址空间，但是访问共享地址空间的不同位置时，代价有明显的区别。

鲲鹏使用ACPI接口，这个启动非0核的过程通过acpi_parking_protocol_cpu_boot()流程
完成，本质上是给对应的核发送IPI_WAKEUP中断。

安全模式
--------

安全模式同样是CPU（核）的一种状态，其原理和特权级的作用原理是一样的。但这个设
计的不是为了控制计算子系统的权限，而是为了控制外设（包括内存）的权限。

鲲鹏提供安全（S）和非安全（NS）两种状态，当CPU处于S状态的时候，发出的所有地址
请求都会包含安全标记。处于安全区的内存或者外设会拒绝所有没有包含这个标记的请求
，这样就在物理上保证了，NS软件不能访问处于安全区的内存或者外设。这为硬件设计者
提供了一个机会，把整个系统分隔成安全和非安全两个部分，而软件上，只有EL3才能进
行NS和S状态的切换。只要控制好这个切换过程，就控制住了安全软件和非安全软件之间
的关系了。

安全模式和特权级是正交关系，每个安全模式都可以有自己的分层关系。这个关系图示如
下：

        .. figure:: kunpeng_secure_mode.svg

和特权级一样，来自安全区的设备中断也会引起CPU的安全模式切换。

运行在S状态中的安全软件，既不是Boot Loader的一部分，也不是Linux Kernel的一部分。
非安全区的Linux Kernel不包含对应的代码，Linux
Kernel（主线v5.5的代码为准，下同），把这些请求封装成了PSCI调用，封装在
arch/arm64/kernel/psic.c中了。但总的来说，主线的Linux Kernel并没有包含多少如何
使用安全OS的设计，因为这是解决方案相关的，取决于如何设计安全方案，大部分方案提
供商也不愿意对外公开自己的设计细节。

        | PSIC
        | todo

todo：ATF软件对外有没有提供？如果有提供在这里。
todo: 这里写的逻辑似乎有些错位。

侧信道攻击问题
--------------
todo：晚点补充

.. vim: fo+=mM tw=78
