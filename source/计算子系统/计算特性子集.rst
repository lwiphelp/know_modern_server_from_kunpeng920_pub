.. Copyright by Kenneth Lee. 2020. All Right Reserved.

计算特性子集
============

综述
----
正如我们在本章开始的时候提到的，计算子系统设计的一个很大的问题是如何平衡空间和
时间的关系。把计算能力分解为多个计算子集提供就是一种平衡的策略。这个策略的思想
是：把所有的计算功能分解为多个子集，软件静态或者动态地决定这些计算子集的使用，
这样虽然不能保证软件一定可以在这些不同目的的实现间互相移植，但可以最大限度地实
现可移植性。

这里说的静态方式，是指软件在编译的时候就决定要使用这个能力，如果目标硬件平台没
有这个能力，这个软件就不能启动，比如基于Neon的软件，在没有实现Neon的硬件上就不
能运行。

而动态方式，是指软件在运行的时候发现被运行的平台是否可以支持某个特定的计算子集
，如果可以才使用这个能力，否则就会退化为使用其他能力。比如鲲鹏的压缩加速器，如
果加速器存在，软件会使用这个硬件加速器进行加速，否则，就会改为使用软件方法进行
压缩。

计算特性子集，可以通过指令集的一个“模块”的方式提供，这一点在RISC-V中表现得最明
显，RISC-V基本上把每个可以独立使用的模块都定义成一种“模块”了，包括乘法，都是独
立于基本指令集的一个模块。这样的好处是可以给硬件设计提供了很大的优化空间，缺点
也很明显，它会让软件非常分裂，难以复用。

鲲鹏920主CPU使用ARMv8的标准，使用一个很大的基本指令集，保证大部分软件互相之间
可以复用，然后再把其他可选功能做成“能力”（Capabilities），尽量使用动态的方式判
断如何把软件投入运行。

增加新的指令集是一种增加计算能力的方法，这种方法我们称为“协处理器方法”，还有一
种方法，我们称为“加速器方法”。两种方法都可以增加指令，区别仅仅是是否把这些指令
作为主处理器的一部分。这一点造成两种模式很大的区别：

如果使用协处理器方法，这个功能需要在CPU保存状态，那么在CPU切换线程的时候，就需
要把这些状态都保存下来。如果对应功能的状态很多，线程切换的成本就会很高。

加速器方法不认为自己是CPU状态的一部分，需要每个进程独占加速器的一个上下文，在
进程释放这个上下文之前，状态都保存在加速器内部，这样线程切换就没有保存上下文的
需要，这个状态留在了加速器的内部。

鲲鹏系列处理器的计算子系统的设计把这种思路作为一个基本的方向，根据计算应用的不
同，中间状态的多少，根据需要安排协处理器和加速器对计算进行支持。鲲鹏920只是这
种思路的初步实施，所以它的通用计算子系统只包含了基本的ARMv8构架的能力，加速器
也仅包含了压缩、加解密这些最基本的功能，但整个鲲鹏的计算子系统的目标不仅仅在这
些功能上，它是从一个更大的层面上安排这个计算能力的。

在本章节中，我们会重点看看通用处理中的浮点和向量计算的设计思路，以及加速器的设
计思路。

浮点和向量计算
--------------

和一般如加减乘除判断这些计算不同，浮点和向量计算常常通过独立的计算单元支持的，
背后的原因是这种计算的流水线超长，一般不容易和其他普通标量计算的计算合并调度。
同时，浮点运算其实本质上是多个定点运算。比如加减法就是把数据的尾数部分按指数的
要求对齐以后进行定点的加减法，而乘除法只需要分别对指数部分和尾数部分分别做定点
乘除就可以完成计算了。

        .. figure:: floating_point_format.svg

在鲲鹏920泰山核的设计中，浮点计算单元和其他定点计算单元并列，它的内部还有自己
的调度队列和很大的寄存器空间，处理器调度是可以把多条浮点或者向量计算请求都送入
浮点计算单元中，乱序执行很多的计算：

        .. figure:: fp_and_vector_unit.svg

这个单元是很典型的协处理器设计，有自己的调度机制和独立的寄存器，计算过程靠把外
部的数据搬移到它自己的寄存器阵列中，然后给它的调度队列发请求。由于这种搬移使用
了主流水线的访存单元，所以它也复用了主处理器的Cache等机制。

在软件设计的时候，尽量减少浮点和向量计算多个计算步骤之间的硬数据依赖，可以更有
效地利用这个计算单元的计算能力。

todo：代码例子

加速器
------

相对独立的完整计算则更适合用加速器来完成，鲲鹏920中集成了多个加解密和压缩引擎
，都采用加速器的设计逻辑，它独立于CPU核，看起来更接近一个外设：

        .. figure:: kp920_acce_arch.svg

每个加速器单元外面都使用了一个相同的模块，称为QM（Queue Manager），QM提供虚拟
PCIE接口的管理，可以提供基于SR-IOV的虚拟设备管理。但更重要的是，它包含了1024个
队列，无论这个加速器背后有多少个实际的加速单元，进程的请求状态都在这个队列中，
所以，无论CPU一侧的进程和线程做什么切换，和协处理单元不同，它都不需要进行状态
保留，但缺点就是这种上下文是有上限的，受QM的最大资源所限。软件设计师要充分利用
这种能力，就需要保证尽快释放不再使用的QM队列。

鲲鹏920的加速器和CPU不在一起，所以它需要使用SMMU（而不是MMU）进行地址翻译，鲲
鹏的软件工程师在Linux内核中加入了一个称为uacce的框架（User Mode Accelerator，
公开的项目名称称为WarpDrive）。uacce的作用是在用户打开一个加速器的时候，给它分
配一个队列，同时把MMU和SMMU的页表合并，这样，对进程来说，CPU和加速器看到的地址
空间完全是一样的，进程可以根据需要，把计算分配给加速器或者CPU执行。

todo：代码例子。


.. vim: fo+=mM tw=78
