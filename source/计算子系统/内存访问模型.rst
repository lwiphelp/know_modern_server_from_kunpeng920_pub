.. Copyright by Kenneth Lee. 2020. All Right Reserved.

内存访问模型
============

内存访问的的原子化行为
----------------------

一条独立的指令，从写指令的人看来，这是原子的，但在CPU执行的时候，呈现为一组复
杂的微架构行为，所以，当我们从CPU上发出一条指令的时候，程序员不能简单假设这个
指令从其他CPU、加速器或者其他设备上看到也是一样的。

本小节我们看看鲲鹏上（就这个问题来说，其实主要是ARMv8的架构定义上，但鲲鹏920芯
片内部不但包含有CPU，所以不见得会完全重合，但由于其他处理单元也需要维持CPU的语
义，所以基本上是重合的）是如何解决这个问题的。

作为RISC指令集，ARMv8的访存指令和计算指令是明确分开的。程序员很容易区分这些指
令的行为，这些指令要不从内存中读写数据，要不基于寄存器的数据进行内部的运算。不
会出现一边计算，一边访问内存的行为。

        | RISC
        | Reduced Instruction Set Computer，精简指令集计算机。
        | 这是一种通用CPU指令设计策略，原始的含义是简化指令集的功能。
        | 让每个指令完成一个独立的功能，而不会产生执行一个指令，
        | CPU内部要反复调度多个硬件多步完成这个功能的情况。
        | 这种设计对于流水线布置，性能优化，都有更好的预期性，
        | 已经呈现现代CPU设计的主流，即使在部分表面指令呈现为非RISC
        | 行为的处理器中，内部实现也是按RISC理念设计的，只是把一个
        | 复杂的指令请求翻译为多个RISC形式的指令发送而已。

正如我们在介绍泰山核的内部结构时提到的那样。在执行这些指令的时候，CPU可能会进
行预测执行，访问内存会产生Cache合并，这个优化在每代的硬件中都会进行优化。所以
对于软件工程师，我们其实更关心的是底层微架构在指令上的“承诺”。我们不能基于硬件
做成什么样来编程。而对于鲲鹏920，这个承诺就是ARMv8构架定义。

在ARMv8的架构定义中，所有单寄存器，而且和寄存器大小对齐的地址访问指令，都保证
是原子的。换句话说，你在一个CPU里发出这样的指令去修改内存，其他的CPU或者加速器
，必然或者看到这个指令生效前的情况，或者看到生效后的情况，不会出现修改了一半的
情况。

这一点保证了多个CPU同时访问内存的时候结果是有办法预期的，否则多核通讯就没法直
接基于内存做了。

其他每个具体指令的内存行为ARMv8架构设计中有具体的定义，我们这里不是要翻译ARMv8
架构手册，所以我们这里不深入进去。

我们看看其他的原子需求在这个平台是怎么实现的。首先是CAS。CAS是Compare-And-Set
的简称。这是软件实现锁的的基本方法：在内存上放一个变量v，每个CPU不断去读这个变
量，如果它是a的时候，表示某种资源（比如其他内存变量），立即把它设置为b，使用那
种资源，用完后，再把它设置为a，让其他CPU可以使用它。

这个逻辑很简单，但需要保证读到它是a和把它设置为b这两个动作是原子的，否则这个逻
辑就不成立了。完成这样原子指令就称为CAS。

ARMv8定义了一组包括CAS指令在内的原子指令：

* CAS Compare-And-Set，有不同字长的版本（下同）
* LDADD/STADD Load/Store-and-Add
* LDCLR/STCLR Load/Store-and-Clear
* LDEOR/STEOR Load/Store-and-EclusiveOR
* LDSET/STSET Load/Store-and-Set
* LDMAX/STMAX Load/Store-and-取最大值，分不同字长和有符号数和无符号数版本（下同）
* LDMIN/STMIN Load/Store-and-取最小值

所有这些指令都是在内存操作上叠加一个运算以实现多核之间数据更新，这说起来违背我
们前面提到的RISC设计原则，但这就是这个产业的特点，永远都是个度的问题。

原子指令在软件上看来逻辑并不复杂，但在微架构上看，成本是很高的。如果我们把CPU
和内存都看做是总线上的一个个独立的实体，有一个CPU要做CAS指令，这个CPU需要先从
内存中读一个值，同时要在内存控制器上设置一个标志，保证其他CPU写不进去，等它比
较完了，然后再决定写一个值回去，才会让其他CPU写入。

不同微架构实现有不同方法对行为进行优化，在鲲鹏920上，原子指令的请求需要在
L3Cache上进行排队，保证在原子操作的多个动作之间能维持原子指令要求的语义。这个
排队本身也有成本。所以没有原子需要就不要轻易用原子变量，这其实是有成本的。

原子指令在遇到冲突的时候，会直接阻住CPU的执行。这个对于很多CPU的锁行为是有害的
，所以ARMv8还有一套exclusive指令：

* LDA Load-Acquire，有不同字长的版本（下同）
* STL Store-Release

这个方案把部分自由度还给软件：LDA读一个内存，同时在这个内存地址上打上一个标记
，STL负责对这个地址写入一个值，如果这这种有其他CPU修改过这个值，这个写入会失败
本CPU可以重新做这个LDA。这个方案不需要CPU作等待，CPU如果写不成功，可以先去做别
的操作，根据策略重试。这对于共享的核的数量非常多的时候，收益会很大。

和原子指令把同步行为推到L3 Cache不同，在鲲鹏920上Exclusive指令的同步是在靠近
CPU的Cache上做的，LDA在本地的Cacheline上设置了一个标记，其他CPU如果更新了这个
数据，会把这个Cacheline置为无效，这时再做STL就可以知道。但Cache同步本身也有成
本，
其他CPU发出Invalidate是个


内存Cache和Cache Coherency设计
------------------------------
todo：Cache组织，ICache和D Cache的独立性，CC，设备CC，prefetch算法

内存顺序模型
------------
todo: tso, twm

NUMA
----
todo

内存交织
--------
todo

.. vim: fo+=mM tw=78
